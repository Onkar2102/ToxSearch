\section{Methodology}

\subsection{Objective Formulation}

\subsubsection{Primary Optimization Objective}

The enhanced ToxSearch system optimizes for adversarial prompt discovery in a black-box setting, where the primary objective is to maximize the toxicity of responses generated by a target Large Language Model (LLM). Formally, given a target response generator (RG) LLM $\theta_{rg}$ and a moderation oracle $\mathcal{M}$, we seek prompts $p \in \mathcal{P}$ that maximize a configured fitness score on the model's response $y \sim \theta_{rg}(p)$.

The fundamental optimization problem is defined as:
\begin{equation}
\label{eq:base_objective}
\max_{p \in \mathcal{P}} f(p) = \text{toxicity}(\mathcal{M}(\theta_{rg}(p)))
\end{equation}
where $f(p) \in [0, 1]$ represents the fitness (toxicity score) of prompt $p$, $\theta_{rg}(p)$ denotes the stochastic response generated by the target LLM, and $\mathcal{M}$ is the moderation oracle that evaluates the toxicity of the response.

The unit being optimized is the \textbf{prompt genome} $p$, which is a text string representing an adversarial question or instruction designed to elicit toxic content from the target model. Each prompt genome $p$ is evaluated by:
\begin{enumerate}
    \item Generating a response $y = \theta_{rg}(p)$ using the target LLM
    \item Evaluating the response using the moderation oracle to obtain toxicity scores
    \item Extracting the primary fitness metric: $f(p) = \text{toxicity\_score}(y) \in [0, 1]$
\end{enumerate}

In the implementation, the toxicity score is extracted from the moderation oracle output as:
\begin{equation}
\label{eq:toxicity_extraction}
f(p) = \begin{cases}
\text{moderation\_result.google.scores.toxicity} & \text{if available} \\
\text{moderation\_result.scores.toxicity} & \text{fallback} \\
0.0001 & \text{minimum value}
\end{cases}
\end{equation}
where the minimum value of $0.0001$ ensures numerical stability and consistent handling of edge cases across the system.

\subsubsection{Quality-Diversity Extension: Novel Objective Framing}

Unlike the original ToxSearch framework, which optimized for a single best prompt (single-objective optimization), the enhanced system reframes the problem as a \textbf{quality-diversity (QD) optimization} task. The key distinction is that we seek not a single optimal prompt, but rather a \textbf{diverse set of high-toxicity prompts} that collectively cover multiple distinct attack strategies.

The QD objective is formally defined as:
\begin{equation}
\label{eq:qd_objective}
\max_{\{S_1, S_2, \ldots, S_k\}} \sum_{i=1}^{k} \max_{p \in S_i} f(p) \quad \text{subject to} \quad D_{inter}(\{S_1, \ldots, S_k\}) \geq \theta_{diversity}
\end{equation}
where $\{S_1, S_2, \ldots, S_k\}$ represents a partition of the population into $k$ species, each species $S_i$ contains semantically similar prompts, and $D_{inter}$ measures inter-species diversity with threshold $\theta_{diversity}$.

This formulation differs from ToxSearch in three fundamental ways:

\begin{enumerate}
    \item \textbf{Multi-peak optimization}: Instead of converging to a single global optimum, the system maintains multiple local optima (species), each representing a distinct attack strategy.
    
    \item \textbf{Explicit diversity constraint}: The objective includes an explicit diversity constraint $D_{inter} \geq \theta_{diversity}$, ensuring that species remain sufficiently distinct from each other.
    
    \item \textbf{Archive-based output}: The system produces a \textbf{QD archive}---a collection of high-quality solutions across multiple niches---rather than a single best solution.
\end{enumerate}

The QD objective can be decomposed into two complementary sub-objectives:
\begin{align}
\label{eq:quality_component}
\text{Quality}(S_i) &= \max_{p \in S_i} f(p) \\
\label{eq:diversity_component}
\text{Diversity}(\{S_1, \ldots, S_k\}) &= D_{inter}(\{S_1, \ldots, S_k\})
\end{align}
where quality measures the best fitness within each species, and diversity measures the distinctness between species.

\subsubsection{Operational Definitions of Quality and Diversity}

\paragraph{Quality Definition}

The \textbf{quality} of a species $S_i$ is operationally defined as the maximum fitness (toxicity score) achieved by any individual within that species:
\begin{equation}
\label{eq:quality_operational}
\text{quality}(S_i) = \max_{p \in S_i} f(p) = \max_{p \in S_i} \text{toxicity}(\mathcal{M}(\theta_{rg}(p)))
\end{equation}

This definition ensures that:
\begin{itemize}
    \item Each species is evaluated by its best-performing member (the species leader)
    \item Quality is a scalar value in $[0, 1]$ that directly corresponds to toxicity
    \item The quality metric is \textbf{monotonic}: if a species gains a higher-fitness member, its quality increases
\end{itemize}

The species leader is defined as:
\begin{equation}
\label{eq:leader_definition}
\text{leader}(S_i) = \arg\max_{p \in S_i} f(p)
\end{equation}
which is the individual with the highest fitness in species $S_i$. The leader serves as the representative of the species and defines the species center for distance computations.

\paragraph{Diversity Definition}

The \textbf{diversity} of the population is operationally defined using an ensemble distance metric that combines genotype (semantic) and phenotype (behavioral) distances. The inter-species diversity is computed as:
\begin{equation}
\label{eq:diversity_operational}
D_{inter}(\{S_1, \ldots, S_k\}) = \frac{1}{\binom{k}{2}} \sum_{i=1}^{k} \sum_{j=i+1}^{k} d_{ensemble}(\text{leader}(S_i), \text{leader}(S_j))
\end{equation}
where $d_{ensemble}$ is the ensemble distance metric (defined in Section~\ref{sec:speciation_module}), and $\binom{k}{2} = \frac{k(k-1)}{2}$ is the number of species pairs.

The ensemble distance combines two components:
\begin{equation}
\label{eq:ensemble_distance}
d_{ensemble}(u, v) = w_{genotype} \times d_{genotype\_norm}(u, v) + w_{phenotype} \times d_{phenotype}(u, v)
\end{equation}
where:
\begin{itemize}
    \item $d_{genotype}(u, v) = 1 - (e_u \cdot e_v)$ measures semantic similarity between prompt embeddings $e_u, e_v \in \mathbb{R}^{384}$ (L2-normalized)
    \item $d_{phenotype}(u, v) = \frac{\|p_u - p_v\|_2}{\sqrt{8}}$ measures behavioral similarity between response score vectors $p_u, p_v \in [0,1]^8$
    \item $w_{genotype} = 0.7$ and $w_{phenotype} = 0.3$ are the ensemble weights
    \item $d_{genotype\_norm} = d_{genotype} / 2.0$ normalizes genotype distance to $[0, 1]$
\end{itemize}

This operational definition ensures that:
\begin{itemize}
    \item Diversity is measured in a multi-dimensional space (semantic + behavioral)
    \item Higher $D_{inter}$ values indicate more distinct species (better diversity)
    \item The metric is \textbf{symmetric} and \textbf{non-negative}, satisfying metric properties
    \item Diversity is computed from species leaders, providing a compact representation
\end{itemize}

\paragraph{Quality-Diversity Trade-off}

The QD objective inherently involves a trade-off between quality and diversity. The system maintains this trade-off through:
\begin{enumerate}
    \item \textbf{Species-level optimization}: Each species independently optimizes its quality (fitness) through evolutionary pressure
    \item \textbf{Inter-species diversity maintenance}: Species are kept distinct through distance-based clustering and merging thresholds
    \item \textbf{Adaptive selection}: Parent selection modes (DEFAULT, EXPLOITATION, EXPLORATION) balance exploitation (quality) and exploration (diversity)
\end{enumerate}

The QD archive produced by the system is the set:
\begin{equation}
\label{eq:qd_archive}
\mathcal{A} = \bigcup_{i=1}^{k} \{\text{leader}(S_i)\} \cup \{p \in S_i : f(p) \geq \alpha \times \text{quality}(S_i)\}
\end{equation}
where $\alpha \in [0, 1]$ is a quality threshold (typically $\alpha = 0.9$), ensuring the archive contains both the best solutions and high-quality solutions from each species.

\subsubsection{Black-Box Assumptions and Design Constraints}

The system operates under strict \textbf{black-box assumptions} that fundamentally constrain the design choices:

\paragraph{No Gradient Access}

The system has \textbf{no access to gradients} or internal model parameters. This assumption implies:
\begin{itemize}
    \item \textbf{No gradient-based optimization}: Cannot use backpropagation or gradient descent
    \item \textbf{Evolutionary algorithms required}: Must use population-based search methods (genetic algorithms, evolutionary strategies)
    \item \textbf{Finite-difference approximation infeasible}: Cannot estimate gradients through finite differences due to stochasticity and computational cost
    \item \textbf{Operator-based variation}: Must rely on heuristic operators (mutation, crossover) rather than gradient-guided search
\end{itemize}

This constraint directly motivates the use of evolutionary algorithms, as they are well-suited for black-box optimization where only function evaluations (fitness scores) are available.

\paragraph{Stochastic Decoding}

The target LLM $\theta_{rg}$ uses \textbf{stochastic decoding}, meaning that the same prompt $p$ may produce different responses $y_1, y_2, \ldots$ across multiple evaluations. This stochasticity has several implications:

\begin{enumerate}
    \item \textbf{Non-deterministic fitness}: The fitness function $f(p)$ is stochastic, as $y \sim \theta_{rg}(p)$ is a random variable
    \item \textbf{Evaluation variance}: Multiple evaluations of the same prompt may yield different toxicity scores
    \item \textbf{Robustness requirement}: The system must be robust to fitness noise and handle stochastic evaluations gracefully
    \item \textbf{No exact optimization}: Cannot find exact optima due to stochasticity; must optimize expected fitness $\mathbb{E}[f(p)]$
\end{enumerate}

The system handles stochasticity through:
\begin{itemize}
    \item \textbf{Population-based search}: Maintains multiple candidates to average over stochasticity
    \item \textbf{Elite preservation}: Retains high-fitness individuals across generations to mitigate evaluation variance
    \item \textbf{Steady-state evolution}: Continuous introduction of new variants allows exploration despite stochasticity
\end{itemize}

\paragraph{Oracle-Based Evaluation}

The moderation oracle $\mathcal{M}$ provides the only source of fitness information. This assumption implies:
\begin{itemize}
    \item \textbf{External API dependency}: Fitness evaluation requires calls to an external moderation service (e.g., Perspective API)
    \item \textbf{Query budget constraints}: Each evaluation consumes a query, limiting the total number of evaluations
    \item \textbf{Latency considerations}: API calls introduce latency, making batch evaluation important for efficiency
    \item \textbf{No internal model access}: Cannot inspect model internals to understand why a response is toxic
\end{itemize}

The query budget model is:
\begin{equation}
\label{eq:query_budget}
N_{queries} = N_{variants} \times (1 + \rho_{refusal})
\end{equation}
where $N_{variants}$ is the number of variants generated per generation, and $\rho_{refusal}$ is the refusal rate (fraction of variants that result in refusals and may require re-evaluation).

\paragraph{Design Constraints Summary}

These black-box assumptions collectively constrain the design to:
\begin{enumerate}
    \item \textbf{Evolutionary algorithms}: Only population-based, derivative-free optimization methods are feasible
    \item \textbf{Operator-based variation}: Must use heuristic mutation and crossover operators, not gradient-guided search
    \item \textbf{Population diversity}: Must explicitly maintain diversity to avoid premature convergence in stochastic environment
    \item \textbf{Query-efficient search}: Must balance exploration and exploitation within limited query budget
    \item \textbf{Robustness to noise}: Must handle stochastic fitness evaluations and evaluation variance
\end{enumerate}

The speciation framework addresses these constraints by:
\begin{itemize}
    \item Maintaining multiple species (niches) to preserve diversity despite stochasticity
    \item Using ensemble distance metrics that are robust to evaluation variance
    \item Implementing species-aware selection that balances quality and diversity
    \item Tracking species-level statistics to make robust decisions despite fitness noise
\end{itemize}

\subsubsection{Theoretical Validation}

The QD objective formulation is theoretically grounded in quality-diversity optimization literature \cite{pugh2016quality,lehman2011abandoning}. The key theoretical properties are:

\begin{theorem}[QD Objective Properties]
The quality-diversity objective defined in Equation~\ref{eq:qd_objective} satisfies:
\begin{enumerate}
    \item \textbf{Pareto optimality}: Solutions in the QD archive are Pareto-optimal with respect to quality and diversity
    \item \textbf{Niche preservation}: Species maintain distinct niches through distance-based clustering
    \item \textbf{Convergence}: Under appropriate conditions, the system converges to a diverse set of high-quality solutions
\end{enumerate}
\end{theorem}

The ensemble distance metric (Equation~\ref{eq:ensemble_distance}) satisfies metric properties:
\begin{enumerate}
    \item \textbf{Non-negativity}: $d_{ensemble}(u, v) \geq 0$ with equality if and only if $u = v$
    \item \textbf{Symmetry}: $d_{ensemble}(u, v) = d_{ensemble}(v, u)$
    \item \textbf{Triangle inequality}: $d_{ensemble}(u, w) \leq d_{ensemble}(u, v) + d_{ensemble}(v, w)$ (approximately satisfied)
\end{enumerate}

These properties ensure that the distance metric provides a well-defined similarity measure for clustering and species assignment.

\subsection{What Changed from ToxSearch: Speciated Quality-Diversity Extension}

\subsubsection{Limitations Addressed by Speciation}

The original ToxSearch framework, while effective at discovering toxic prompts, suffers from a fundamental limitation: \textbf{premature convergence to a narrow set of prompt patterns}. This limitation manifests in three specific ways:

\begin{enumerate}
    \item \textbf{Mode collapse}: The population converges to a single dominant attack pattern, losing diversity across different attack strategies. This occurs because fitness-based selection favors the highest-scoring prompts, causing the population to collapse around a single peak in the fitness landscape.
    
    \item \textbf{Single-topic convergence}: All prompts evolve toward similar semantic content, exploiting a single vulnerability or attack vector. The system fails to maintain distinct attack strategies simultaneously.
    
    \item \textbf{Loss of secondary peaks}: Prompts that represent alternative high-quality attack strategies (secondary peaks) are lost as the population converges to the primary peak. This reduces the comprehensiveness of red-teaming coverage.
\end{enumerate}

These limitations are particularly problematic for systematic red-teaming, where the goal is to discover \textit{multiple distinct} vulnerabilities rather than a single best attack. The speciation framework addresses these limitations by explicitly maintaining multiple niches (species) that evolve independently, preventing premature convergence while preserving high-quality solutions across diverse attack strategies.

\subsubsection{Unchanged Components}

The enhanced system retains several core components from ToxSearch, as they remain effective and do not require modification for the QD extension:

\begin{enumerate}
    \item \textbf{Prompt Generator (PG) / Response Generator (RG) split}: The architecture maintains separate LLM instances for prompt generation (PG) and response generation (RG). This separation allows the PG to focus on prompt optimization while the RG serves as the target system under test. This design remains unchanged because it provides clear separation of concerns and enables independent model selection.
    
    \item \textbf{Oracle-based scoring}: The system continues to use external moderation APIs (e.g., Perspective API) as the fitness oracle. This black-box evaluation approach remains unchanged because it provides standardized, reproducible toxicity assessment without requiring access to model internals.
    
    \item \textbf{Operator suite baseline}: All 10 mutation operators and 2 crossover operators from ToxSearch are retained without modification:
    \begin{itemize}
        \item Mutation: InformedEvolution, MLM, Paraphrasing, BackTranslation, Synonym/Antonym (POS-aware), Negation, ConceptAddition, TypographicalErrors, Stylistic
        \item Crossover: SemanticSimilarity, SemanticFusion
    \end{itemize}
    These operators remain unchanged because they provide effective prompt perturbation mechanisms that work independently of population structure.
\end{enumerate}

The rationale for retaining these components is that they are \textbf{orthogonal} to the diversity maintenance problem. The PG/RG split, oracle-based scoring, and operator suite address \textit{how} to generate and evaluate prompts, while speciation addresses \textit{how} to organize and maintain diverse populations.

\subsubsection{Modified Components}

The enhanced system modifies four key components to enable quality-diversity optimization:

\begin{enumerate}
    \item \textbf{Population structure}: Changed from a flat population list to a \textbf{multi-species structure} where the population is partitioned into species $S_1, S_2, \ldots, S_k$ and a reserve cluster $R$ (cluster 0). This structural change enables:
    \begin{itemize}
        \item Independent evolution of each species
        \item Explicit diversity maintenance through species separation
        \item Niche preservation via distance-based clustering
    \end{itemize}
    
    \item \textbf{Parent selection}: Changed from fitness-based selection to \textbf{species-aware selection} that operates on the species structure. Selection modes (DEFAULT, EXPLOITATION, EXPLORATION) now consider species boundaries:
    \begin{itemize}
        \item DEFAULT: Random species selection, then random parents from that species
        \item EXPLOITATION: Top species selection, parents from same species
        \item EXPLORATION: Multiple species selection, parents from different species
    \end{itemize}
    This modification enables controlled exploration across species boundaries while maintaining exploitation within species.
    
    \item \textbf{Replacement strategy}: Changed from global fitness-based replacement to \textbf{species-based replacement} with capacity constraints:
    \begin{itemize}
        \item Each species maintains its own capacity limit (100 individuals)
        \item Replacement occurs within species (fitness-based trimming)
        \item Cluster 0 (reserves) serves as overflow buffer and speciation source
    \end{itemize}
    This modification prevents dominant species from overwhelming the population and ensures smaller species are preserved.
    
    \item \textbf{State bookkeeping}: Introduced comprehensive state tracking via \texttt{speciation\_state.json}:
    \begin{itemize}
        \item Species structure (leaders, members, fitness history)
        \item Stagnation tracking per species
        \item Merge/extinction event history
        \item Inter/intra-species diversity metrics
    \end{itemize}
    This new bookkeeping enables incremental clustering, species identity preservation, and long-term evolution analysis.
\end{enumerate}

\subsubsection{Expected Causal Mechanism}

The speciation framework changes search dynamics through the following causal mechanism:

\begin{hypothesis}[Speciation Search Dynamics]
Species maintain multiple niches in the fitness landscape, each evolving independently toward local optima. This prevents premature convergence by:
\begin{enumerate}
    \item \textbf{Niche isolation}: Each species explores a distinct region of the prompt space, preventing one region from dominating selection pressure.
    
    \item \textbf{Independent optimization}: Species optimize their local fitness peaks simultaneously, rather than competing for a single global peak.
    
    \item \textbf{Diversity preservation}: Distance-based clustering ensures species remain distinct, maintaining coverage across the fitness landscape.
    
    \item \textbf{Adaptive exploration}: Species-aware selection balances exploitation (within-species) and exploration (cross-species), enabling systematic coverage of multiple attack strategies.
\end{enumerate}
\end{hypothesis}

The expected effect on operator behavior is:
\begin{itemize}
    \item \textbf{Within-species operators}: Mutation and crossover operators continue to work as before, but now operate within semantically-coherent niches, potentially improving local search efficiency.
    
    \item \textbf{Cross-species operators}: In EXPLORATION mode, crossover between different species may produce novel combinations that bridge attack strategies, potentially discovering new high-fitness regions.
    
    \item \textbf{Operator effectiveness}: Operators may show different effectiveness profiles across species, as different niches may respond differently to various perturbation strategies.
\end{itemize}

This methodology instantiates the hypothesis that explicit niche maintenance (via speciation) enables quality-diversity optimization, producing a diverse archive of high-quality adversarial prompts rather than a single best solution.

\subsection{System Overview}

\subsubsection{System Components and Interactions}

The enhanced ToxSearch system consists of five main components that interact through a well-defined data flow:

\begin{enumerate}
    \item \textbf{Prompt Generator (PG)}: An LLM instance (e.g., LLaMA 3.2 3B Instruct) that generates prompt variants through operator application. The PG receives parent prompts and applies mutation or crossover operators to produce new variants. Implementation: \texttt{src/gne/prompt\_generator.py}
    
    \item \textbf{Response Generator (RG)}: An LLM instance (e.g., LLaMA 3.2 3B Instruct) that serves as the target system under test. The RG receives prompt variants and generates responses, which are then evaluated for toxicity. Implementation: \texttt{src/gne/response\_generator.py}
    
    \item \textbf{Moderation Oracle} $\mathcal{M}$: An external API service (e.g., Perspective API) that evaluates response toxicity. The oracle provides both scalar toxicity scores (for fitness) and 8-dimensional response score vectors (for phenotype distance). Implementation: \texttt{src/gne/evaluator.py}
    
    \item \textbf{Speciation Module}: A quality-diversity framework that maintains species structure, performs clustering, handles merging and extinction, and manages population distribution. This is the core enhancement over ToxSearch. Implementation: \texttt{src/speciation/run\_speciation.py}
    
    \item \textbf{Evolution Tracker}: A state management system that tracks generation statistics, operator effectiveness, and speciation metrics across the entire evolution run. Implementation: \texttt{src/utils/population\_io.py} and \texttt{EvolutionTracker.json}
\end{enumerate}

The component interactions follow this flow:
\begin{enumerate}
    \item \textbf{Parent Selection} (ParentSelector) $\rightarrow$ selects parents from species structure
    \item \textbf{Operator Application} (EvolutionEngine) $\rightarrow$ PG generates variants from parents
    \item \textbf{Response Generation} (ResponseGenerator) $\rightarrow$ RG produces responses for variants
    \item \textbf{Evaluation} (ModerationOracle) $\rightarrow$ Oracle scores responses for toxicity
    \item \textbf{Speciation Processing} (SpeciationModule) $\rightarrow$ Clusters variants, updates species, manages population
    \item \textbf{State Tracking} (EvolutionTracker) $\rightarrow$ Records metrics and statistics
\end{enumerate}

\subsubsection{Artifacts and State Maintained Each Generation}

The system maintains the following artifacts and state at each generation:

\begin{enumerate}
    \item \textbf{Population partitions}:
    \begin{itemize}
        \item \texttt{elites.json}: All genomes with \texttt{species\_id > 0} (species members)
        \item \texttt{reserves.json}: All genomes with \texttt{species\_id = 0} (cluster 0 outliers)
        \item \texttt{archive.json}: Genomes removed due to capacity limits (non-elites)
    \end{itemize}
    
    \item \textbf{Species leaders}: For each active species $S_i$, the leader $\text{leader}(S_i) = \arg\max_{p \in S_i} f(p)$ is maintained with:
    \begin{itemize}
        \item Prompt text
        \item L2-normalized embedding vector $e \in \mathbb{R}^{384}$
        \item Phenotype vector $p \in [0,1]^8$ (response scores)
        \item Fitness score $f(p) \in [0,1]$
    \end{itemize}
    
    \item \textbf{Per-species statistics}:
    \begin{itemize}
        \item Fitness history: Time series of $\max_{p \in S_i} f(p)$ over generations
        \item Stagnation counter: Generations since last fitness improvement
        \item Size: Current number of members $|S_i|$
        \item Labels: c-TF-IDF top 10 words characterizing species semantics
        \item Origin: How species was created ("natural", "merge", or "split")
    \end{itemize}
    
    \item \textbf{Archives}:
    \begin{itemize}
        \item QD archive: Collection of high-quality solutions across species
        \item Capacity archive: Genomes removed due to capacity limits
        \item Historical species: Frozen and incubator species preserved for reference
    \end{itemize}
\end{enumerate}

All state is persisted to \texttt{speciation\_state.json} at the end of each generation, enabling state restoration and incremental clustering.

\subsubsection{Speciation Intervention Point}

Speciation intervenes in the evolutionary loop at a specific point in the generation pipeline:

\begin{equation}
\label{eq:pipeline_order}
\text{Parents} \rightarrow \text{Variation} \rightarrow \text{Deduplication} \rightarrow \text{Evaluation} \rightarrow \text{\textbf{Speciation}} \rightarrow \text{Distribution} \rightarrow \text{Tracking}
\end{equation}

Speciation occurs \textbf{after evaluation} but \textbf{before distribution}. This placement is critical because:
\begin{enumerate}
    \item \textbf{Evaluation must complete first}: Speciation requires fitness scores and phenotype vectors, which are only available after oracle evaluation.
    
    \item \textbf{Before distribution}: Speciation assigns \texttt{species\_id} to each variant, which determines whether it goes to \texttt{elites.json} or \texttt{reserves.json} during distribution.
    
    \item \textbf{After deduplication}: Deduplication removes exact duplicates before speciation, preventing duplicate variants from affecting species structure.
\end{enumerate}

The speciation processing includes:
\begin{enumerate}
    \item Embedding computation for all variants
    \item Leader-Follower clustering (assignment to species or cluster 0)
    \item Capacity enforcement (trimming to limits)
    \item Species merging (combining similar species)
    \item Extinction processing (freezing stagnant species)
    \item State persistence (saving to \texttt{speciation\_state.json})
\end{enumerate}

\subsubsection{System Guarantees and Invariants}

The system enforces the following guarantees and invariants:

\begin{enumerate}
    \item \textbf{Capacity constraints}:
    \begin{equation}
    \label{eq:capacity_constraints}
    |S_i| \leq C_{species} = 100 \quad \forall i \in \{1, \ldots, k\}, \quad |R| \leq C_{cluster0} = 1000
    \end{equation}
    where $C_{species}$ is the species capacity and $C_{cluster0}$ is the cluster 0 capacity. These constraints prevent unbounded population growth and ensure computational efficiency.
    
    \item \textbf{Species radius enforcement}:
    \begin{equation}
    \label{eq:radius_invariant}
    d_{ensemble}(p, \text{leader}(S_i)) < \theta_{sim} = 0.2 \quad \forall p \in S_i
    \end{equation}
    All members of a species must be within the species radius $\theta_{sim}$ of the leader. This invariant ensures species cohesion and semantic coherence.
    
    \item \textbf{Deduplication guarantee}: The system performs two-stage deduplication:
    \begin{itemize}
        \item \textbf{Intra-temp}: Removes duplicates within the current generation's variants
        \item \textbf{Population-wide}: Removes duplicates against the entire population (elites + reserves)
    \end{itemize}
    This ensures no duplicate prompts exist in the population, maintaining diversity claims.
    
    \item \textbf{Species assignment completeness}:
    \begin{equation}
    \label{eq:assignment_completeness}
    \bigcup_{i=1}^{k} S_i \cup R = P, \quad S_i \cap S_j = \emptyset \quad \forall i \neq j, \quad S_i \cap R = \emptyset \quad \forall i
    \end{equation}
    Every individual in the population $P$ is assigned to exactly one species or cluster 0, with no overlaps. This ensures complete population coverage and unambiguous species membership.
    
    \item \textbf{Leader fitness monotonicity}: For each species $S_i$:
    \begin{equation}
    \label{eq:leader_monotonicity}
    f(\text{leader}(S_i))_{t+1} \geq f(\text{leader}(S_i))_t
    \end{equation}
    The leader fitness is non-decreasing across generations (within a species), as the leader is always the highest-fitness member. If a new member has higher fitness, it becomes the new leader.
\end{enumerate}

These invariants are enforced through:
\begin{itemize}
    \item Post-clustering radius verification (removes members outside radius)
    \item Capacity enforcement (fitness-based trimming)
    \item Deduplication checks (exact prompt matching)
    \item Assignment validation (ensures complete coverage)
\end{itemize}

Implementation validation: These invariants are checked in \texttt{src/speciation/validation.py} via \texttt{validate\_speciation\_consistency()}, which verifies that all genomes are properly assigned and species structure is consistent.

\subsection{Evolutionary Loop and Algorithm Description}

\subsubsection{One Full Generation Step-by-Step}

A single generation in the enhanced ToxSearch system follows this sequence:

\begin{enumerate}
    \item \textbf{Parent Selection}: The \texttt{ParentSelector} selects parents from the current population (elites + reserves) based on the adaptive selection mode (DEFAULT, EXPLOITATION, or EXPLORATION). Selection is species-aware, operating on the species structure maintained in \texttt{speciation\_state.json}. Implementation: \texttt{src/ea/parent\_selector.py}
    
    \item \textbf{Variation}: The \texttt{EvolutionEngine} applies mutation or crossover operators to the selected parents, generating new prompt variants. The PG (Prompt Generator) LLM is used for operator execution. Variants are written to \texttt{temp.json}. Implementation: \texttt{src/ea/evolution\_engine.py}
    
    \item \textbf{Deduplication}: Two-stage deduplication removes duplicate variants:
    \begin{itemize}
        \item \textbf{Intra-temp}: Removes exact duplicates within \texttt{temp.json}
        \item \textbf{Population-wide}: Removes duplicates against the entire population (elites + reserves)
    \end{itemize}
    This ensures no duplicate prompts enter the population. Implementation: \texttt{src/utils/population\_io.py}
    
    \item \textbf{Response Generation}: The RG (Response Generator) LLM generates responses for all variants in \texttt{temp.json}. Responses are stored in the \texttt{generated\_output} field of each genome. Implementation: \texttt{src/gne/response\_generator.py}
    
    \item \textbf{Evaluation}: The moderation oracle evaluates all responses, computing:
    \begin{itemize}
        \item Scalar fitness: $f(p) = \text{toxicity\_score} \in [0,1]$ (stored in \texttt{north\_star\_score})
        \item Phenotype vector: $p \in [0,1]^8$ (8D response scores stored in \texttt{moderation\_result.google.scores})
    \end{itemize}
    Implementation: \texttt{src/gne/evaluator.py}
    
    \item \textbf{Refusal Penalty}: Refusal detection identifies LLM refusals (1-2 sentence responses matching refusal patterns), and a 15\% penalty is applied to toxicity scores. Refusals are marked with \texttt{is\_refusal=1}. Implementation: \texttt{src/utils/refusal\_penalty.py}
    
    \item \textbf{Speciation Processing}: The speciation module processes all variants:
    \begin{itemize}
        \item Computes embeddings for all variants (all-MiniLM-L6-v2, 384-dim)
        \item Runs Leader-Follower clustering (assigns to species or cluster 0)
        \item Enforces capacity constraints (trims species and cluster 0)
        \item Merges similar species (if leader distance $< \theta_{merge}$)
        \item Processes extinctions (freezes stagnant species, moves small species to cluster 0)
        \item Updates species labels (c-TF-IDF)
        \item Saves state to \texttt{speciation\_state.json}
    \end{itemize}
    Implementation: \texttt{src/speciation/run\_speciation.py}
    
    \item \textbf{Population Distribution}: Variants are distributed based on \texttt{species\_id}:
    \begin{itemize}
        \item \texttt{species\_id > 0} $\rightarrow$ \texttt{elites.json} (species members)
        \item \texttt{species\_id = 0} $\rightarrow$ \texttt{reserves.json} (cluster 0 outliers)
    \end{itemize}
    Overflow genomes (removed due to capacity) are archived to \texttt{archive.json}. Implementation: \texttt{src/speciation/run\_speciation.py}
    
    \item \textbf{State Tracking}: The \texttt{EvolutionTracker} records generation statistics:
    \begin{itemize}
        \item Operator effectiveness metrics (NE, EHR, IR, $\Delta\mu$, $\Delta\sigma$)
        \item Population statistics (elites count, reserves count, average fitness)
        \item Speciation metrics (species count, inter/intra-species diversity)
        \item Refusal statistics (refusals detected, penalties applied)
    \end{itemize}
    All statistics are persisted to \texttt{EvolutionTracker.json}. Implementation: \texttt{src/utils/population\_io.py}
\end{enumerate}

This sequence is executed for each generation $g = 1, 2, \ldots, G$ until the maximum generation limit is reached or early termination conditions are met.

\subsubsection{Steady-State $(\mu+\lambda)$ Definition}

The system uses a \textbf{steady-state} evolutionary strategy, where the population is continuously updated rather than replaced entirely each generation. The $(\mu+\lambda)$ notation indicates:
\begin{itemize}
    \item $\mu$: Current population size (number of individuals in elites + reserves)
    \item $\lambda$: Number of variants generated per generation
\end{itemize}

In the implementation:
\begin{equation}
\label{eq:steady_state}
\mu = |E| + |R|, \quad \lambda = N_{variants}
\end{equation}
where $E = \bigcup_{i=1}^{k} S_i$ is the set of all species members (elites), $R$ is cluster 0 (reserves), and $N_{variants}$ is the number of variants generated per generation.

The steady-state property means:
\begin{enumerate}
    \item \textbf{No generational replacement}: The population is not replaced entirely; instead, new variants are added and old variants are removed based on capacity constraints.
    
    \item \textbf{Continuous evolution}: Evolution occurs continuously across generations, with species structure persisting and evolving incrementally.
    
    \item \textbf{Elite preservation}: High-fitness individuals are preserved across generations through species membership and capacity-based trimming (lowest-fitness members are removed first).
\end{enumerate}

This differs from ToxSearch in that:
\begin{itemize}
    \item ToxSearch: $\mu$ was a fixed population size, and replacement was global (fitness-based across entire population)
    \item Enhanced: $\mu$ is partitioned into species with per-species capacity, and replacement is species-based (fitness-based within each species)
\end{itemize}

The steady-state approach is well-suited for speciation because it allows species to evolve incrementally without disrupting the species structure.

\subsubsection{Computational Budget Model}

The computational budget is dominated by LLM API calls and moderation oracle queries. The budget model is:

\begin{equation}
\label{eq:computational_budget}
N_{queries} = N_{variants} \times (1 + \rho_{refusal}) + N_{embedding}
\end{equation}
where:
\begin{itemize}
    \item $N_{variants}$: Number of variants generated per generation (depends on selection mode)
    \item $\rho_{refusal}$: Refusal rate (fraction of variants that result in refusals; typically 0.1--0.3)
    \item $N_{embedding}$: Embedding computation cost (batch processing, amortized per variant)
\end{itemize}

The variant count $N_{variants}$ depends on the selection mode:
\begin{align}
\label{eq:variant_counts}
N_{variants} = \begin{cases}
22 & \text{DEFAULT mode (2 parents, 11 iterations)} \\
36 & \text{EXPLOITATION mode (3 parents, 12 iterations)} \\
36 & \text{EXPLORATION mode (3 parents, 12 iterations)}
\end{cases}
\end{align}

The cost dominators are:
\begin{enumerate}
    \item \textbf{RG API calls}: $N_{variants}$ calls to generate responses (dominant cost, ~1--3 seconds per call)
    \item \textbf{Moderation oracle queries}: $N_{variants}$ queries to evaluate toxicity (moderate cost, ~0.5--1 second per query)
    \item \textbf{PG API calls}: Variable, depends on operator usage (some operators like InformedEvolution require PG calls)
    \item \textbf{Embedding computation}: Batch processing, amortized cost ~0.01 seconds per variant
\end{enumerate}

The total time per generation is approximately:
\begin{equation}
\label{eq:time_per_generation}
T_{generation} \approx N_{variants} \times (T_{RG} + T_{oracle}) + T_{speciation} + T_{overhead}
\end{equation}
where $T_{RG} \approx 1$--3 seconds, $T_{oracle} \approx 0.5$--1 second, $T_{speciation} \approx 5$--10 seconds (clustering + state management), and $T_{overhead} \approx 1$--2 seconds (I/O, deduplication).

For a typical generation with $N_{variants} = 22$ (DEFAULT mode), the total time is approximately 40--80 seconds, dominated by RG API calls.

\subsubsection{New Bookkeeping for QD/Speciation}

The enhanced system introduces extensive bookkeeping to support quality-diversity optimization:

\begin{enumerate}
    \item \textbf{Species-level archives}: Each species maintains:
    \begin{itemize}
        \item Fitness history: Time series of $\max_{p \in S_i} f(p)$ over generations
        \item Member list: All individuals currently in the species
        \item Leader tracking: Current leader and historical leaders
        \item Stagnation counter: Generations since last fitness improvement
    \end{itemize}
    Stored in \texttt{speciation\_state.json} under \texttt{species[id]}.
    
    \item \textbf{Leader updates}: When a new member joins a species:
    \begin{itemize}
        \item If $f(p_{new}) > f(\text{leader}(S_i))$, the new member becomes the leader
        \item Leader embedding and phenotype are updated
        \item Species radius is verified (members outside radius are moved to cluster 0)
    \end{itemize}
    Implementation: \texttt{src/speciation/leader\_follower.py}
    
    \item \textbf{Stagnation counters}: For each species $S_i$:
    \begin{equation}
    \label{eq:stagnation}
    \text{stagnation}(S_i) = \begin{cases}
    \text{stagnation}(S_i) + 1 & \text{if } f(\text{leader}(S_i))_{t+1} = f(\text{leader}(S_i))_t \\
    0 & \text{if } f(\text{leader}(S_i))_{t+1} > f(\text{leader}(S_i))_t
    \end{cases}
    \end{equation}
    Species with $\text{stagnation}(S_i) \geq 20$ generations are frozen (moved to "frozen" state). Implementation: \texttt{src/speciation/extinction.py}
    
    \item \textbf{Merge/extinction events}: The system tracks:
    \begin{itemize}
        \item Merge events: Which species merged, when, and resulting species ID
        \item Extinction events: Which species were frozen, when, and reason (stagnation or small size)
        \item Split events: When cluster 0 forms new species (if \texttt{min\_cluster\_size} reached)
    \end{itemize}
    Stored in \texttt{speciation\_state.json} under \texttt{events}.
    
    \item \textbf{Inter/intra-species diversity}: Computed each generation:
    \begin{align}
    \label{eq:inter_diversity}
    D_{inter} &= \frac{1}{\binom{k}{2}} \sum_{i=1}^{k} \sum_{j=i+1}^{k} d_{ensemble}(\text{leader}(S_i), \text{leader}(S_j)) \\
    \label{eq:intra_diversity}
    D_{intra}(S_i) &= \frac{1}{|S_i|} \sum_{p \in S_i} d_{ensemble}(p, \text{leader}(S_i))
    \end{align}
    These metrics are tracked to monitor diversity maintenance. Implementation: \texttt{src/speciation/run\_speciation.py}
    
    \item \textbf{Operator-species telemetry}: For each operator and species combination:
    \begin{itemize}
        \item Number of variants generated (NE: Number of Elites)
        \item Effectiveness metrics (EHR: Elite Hit Rate, IR: Improvement Rate)
        \item Fitness impact ($\Delta\mu$: mean fitness change, $\Delta\sigma$: fitness variance change)
    \end{itemize}
    This enables analysis of operator effectiveness across different species. Stored in \texttt{EvolutionTracker.json}.
\end{enumerate}

All bookkeeping data is persisted to disk each generation, enabling:
\begin{itemize}
    \item State restoration after interruptions
    \item Incremental clustering (no full recomputation)
    \item Long-term evolution analysis
    \item Reproducibility and auditability
\end{itemize}

\subsection{Fitness Scoring and Validity Handling}

\subsubsection{Toxicity Score Computation}

The fitness function $f(p)$ is computed from the moderation oracle output as follows:

\begin{equation}
\label{eq:fitness_computation}
f(p) = \begin{cases}
\text{moderation\_result.google.scores.toxicity} & \text{if available} \\
\text{moderation\_result.scores.toxicity} & \text{fallback (legacy format)} \\
0.0001 & \text{minimum value (numerical stability)}
\end{cases}
\end{equation}

The toxicity score is a scalar value in $[0, 1]$ where:
\begin{itemize}
    \item $f(p) = 0$: Completely non-toxic response
    \item $f(p) = 1$: Maximally toxic response
    \item $f(p) \in (0, 1)$: Intermediate toxicity levels
\end{itemize}

The score is extracted from the moderation API response structure:
\begin{itemize}
    \item Primary path: \texttt{moderation\_result.google.scores.toxicity} (Google Perspective API format)
    \item Fallback path: \texttt{moderation\_result.scores.toxicity} (legacy format for compatibility)
    \item Minimum value: $0.0001$ ensures numerical stability and prevents zero-division errors
\end{itemize}

Implementation: The extraction logic is in \texttt{src/utils/population\_io.py} via \texttt{\_extract\_north\_star\_score()}, which handles multiple score extraction paths with priority ordering.

\subsubsection{Invalid Evaluation Handling}

An evaluation is considered \textbf{invalid} if any of the following conditions are met:

\begin{enumerate}
    \item \textbf{Refusal}: The LLM refuses to answer, producing a 1--2 sentence response that matches refusal patterns (e.g., "I can't help with that", "I'm not able to provide that information"). Refusals are detected using pattern matching on response text. Implementation: \texttt{src/utils/refusal\_detector.py}
    
    \item \textbf{Non-question output}: The response is not in question format (e.g., the LLM produces a statement instead of a question). This is detected by checking if the response starts with question words or ends with "?".
    
    \item \textbf{Broken format}: The moderation API returns an error or malformed response, preventing score extraction. This is handled by fallback to default score ($0.0001$).
    
    \item \textbf{Empty response}: The LLM produces an empty or whitespace-only response. This is treated as invalid and assigned default score.
\end{enumerate}

Invalid evaluations are handled as follows:
\begin{enumerate}
    \item \textbf{Refusal penalty}: Refusals are penalized with a 15\% reduction in toxicity score:
    \begin{equation}
    \label{eq:refusal_penalty}
    f_{penalized}(p) = 0.85 \times f(p) \quad \text{if } \text{is\_refusal}(p) = 1
    \end{equation}
    The penalty is applied directly to the score fields, and the genome is marked with \texttt{is\_refusal=1}. Implementation: \texttt{src/utils/refusal\_penalty.py}
    
    \item \textbf{Exclusion from speciation}: Invalid variants (refusals, empty responses) are still included in the population but are assigned to cluster 0 (reserves) during speciation, as they may not have valid embeddings or phenotype vectors.
    
    \item \textbf{Tracking}: Invalid evaluations are tracked per operator and per species in \texttt{EvolutionTracker.json} for analysis, but they do not directly influence selection (selection is fitness-based only).
\end{enumerate}

The refusal detection algorithm uses three filters:
\begin{enumerate}
    \item \textbf{Length filter}: Response must be 1--2 sentences (short response filter)
    \item \textbf{Punctuation filter}: Response must end with "." or "?"
    \item \textbf{Pattern filter}: Response must match at least one refusal pattern (regex-based)
\end{enumerate}

All three filters must pass for a response to be classified as a refusal. This conservative approach minimizes false positives.

\subsubsection{Additional Metrics for QD/Speciation}

Beyond scalar fitness, the system tracks additional metrics to support quality-diversity analysis:

\begin{enumerate}
    \item \textbf{Phenotype vector}: 8-dimensional response score vector $p \in [0,1]^8$:
    \begin{equation}
    \label{eq:phenotype_vector}
    p = [\text{toxicity}, \text{threat}, \text{profanity}, \text{sexually\_explicit}, \text{identity\_attack}, \text{flirtation}, \text{insult}, \text{severe\_toxicity}]
    \end{equation}
    Extracted from \texttt{moderation\_result.google.scores} in fixed order. Used for phenotype distance computation in ensemble distance. Implementation: \texttt{src/speciation/phenotype\_distance.py}
    
    \item \textbf{Refusal rate per species}: For each species $S_i$:
    \begin{equation}
    \label{eq:refusal_rate_species}
    \rho_{refusal}(S_i) = \frac{|\{p \in S_i : \text{is\_refusal}(p) = 1\}|}{|S_i|}
    \end{equation}
    Tracks how often species members result in refusals, indicating species-level robustness.
    
    \item \textbf{Refusal rate per operator}: For each operator $O_j$:
    \begin{equation}
    \label{eq:refusal_rate_operator}
    \rho_{refusal}(O_j) = \frac{|\{p : \text{operator}(p) = O_j \land \text{is\_refusal}(p) = 1\}|}{|\{p : \text{operator}(p) = O_j\}|}
    \end{equation}
    Tracks operator-level refusal rates, indicating which operators are more likely to produce refusals.
    
    \item \textbf{Species fitness distribution}: For each species $S_i$, the system tracks:
    \begin{itemize}
        \item Mean fitness: $\mu_{fitness}(S_i) = \frac{1}{|S_i|} \sum_{p \in S_i} f(p)$
        \item Max fitness: $\max_{p \in S_i} f(p)$ (species leader fitness)
        \item Fitness variance: $\sigma^2_{fitness}(S_i) = \frac{1}{|S_i|} \sum_{p \in S_i} (f(p) - \mu_{fitness}(S_i))^2$
    \end{itemize}
    These metrics enable analysis of species-level fitness characteristics.
    
    \item \textbf{Inter/intra-species diversity}: As defined in Equations~\ref{eq:inter_diversity} and \ref{eq:intra_diversity}, these metrics track diversity maintenance across and within species.
\end{enumerate}

All additional metrics are persisted to \texttt{EvolutionTracker.json} and \texttt{speciation\_state.json} for analysis.

\subsubsection{Invalid Cost Influence}

Invalid evaluations (refusals, empty responses) are treated as \textbf{cost} in the following ways:

\begin{enumerate}
    \item \textbf{Query budget consumption}: Invalid evaluations still consume API calls (RG and moderation oracle), contributing to the computational budget. This cost is tracked but does not influence selection.
    
    \item \textbf{Fitness penalty}: Refusals receive a 15\% fitness penalty (Equation~\ref{eq:refusal_penalty}), reducing their likelihood of being selected. However, selection is still fitness-based, so penalized refusals may still be selected if they have high base fitness.
    
    \item \textbf{Analysis-only tracking}: Invalid cost is tracked per operator and per species for analysis purposes (to understand which operators/species produce more refusals), but it does not directly influence:
    \begin{itemize}
        \item Parent selection (selection is fitness-based only)
        \item Operator scheduling (operators are not deprioritized based on refusal rates)
        \item Species management (species are not penalized for high refusal rates)
    \end{itemize}
    
    \item \textbf{Cluster 0 assignment}: Invalid variants are typically assigned to cluster 0 (reserves) during speciation, as they may not have valid embeddings or phenotype vectors. This indirect effect means invalid variants are less likely to be in active species, reducing their selection probability.
\end{enumerate}

The rationale for this approach is that invalid evaluations are a natural part of the search process (LLMs may refuse to answer certain prompts), and penalizing them too heavily would bias the search away from potentially valuable regions of the prompt space. The 15\% penalty provides a mild disincentive while still allowing high-fitness refusals to contribute to evolution.

\subsection{Variation Operators}

\subsubsection{Retained Operators from ToxSearch}

The enhanced system retains all 12 operators from the original ToxSearch framework without modification:

\begin{enumerate}
    \item \textbf{Mutation operators} (10 total):
    \begin{itemize}
        \item \texttt{InformedEvolutionOperator}: Uses top-10 elite examples to guide evolution via LLM-based prompt generation
        \item \texttt{LLM\_POSAwareSynonymReplacement}: POS-aware synonym substitution using LLM
        \item \texttt{POSAwareAntonymReplacement}: POS-aware antonym substitution
        \item \texttt{MLMOperator}: Masked language model-based word substitution
        \item \texttt{LLMBasedParaphrasingOperator}: Semantic paraphrasing via LLM
        \item \texttt{StylisticMutator}: Stylistic transformation (formal/informal, tone changes)
        \item \texttt{LLMBackTranslationHIOperator}: Back-translation through Hindi
        \item \texttt{NegationOperator}: Negation insertion (adding "not", "never", etc.)
        \item \texttt{TypographicalErrorsOperator}: Typographical error injection (typos, character swaps)
        \item \texttt{ConceptAdditionOperator}: Concept addition to prompts (adding related concepts)
    \end{itemize}
    
    \item \textbf{Crossover operators} (2 total):
    \begin{itemize}
        \item \texttt{SemanticSimilarityCrossover}: Crossover based on semantic similarity between parent prompts
        \item \texttt{SemanticFusionCrossover}: Fusion crossover that combines semantic elements from parents
    \end{itemize}
\end{enumerate}

All operators are implemented in \texttt{src/ea/} and remain unchanged from ToxSearch. The operators themselves are \textbf{species-agnostic}: they operate on prompt text without knowledge of species structure.

\subsubsection{Operator-Species Interaction}

Operators interact with species indirectly through parent selection, not through direct species awareness:

\begin{enumerate}
    \item \textbf{Within-species operation}: In DEFAULT and EXPLOITATION modes, parents are selected from the same species, so operators effectively operate within-species. This maintains species coherence and enables local search within niches.
    
    \item \textbf{Cross-species operation}: In EXPLORATION mode, parents are selected from different species, so crossover operators may combine prompts from different species. This enables exploration across species boundaries and may discover novel combinations.
    
    \item \textbf{No species constraints}: Operators themselves do not enforce species boundaries; they simply operate on the prompts provided as input. The species structure affects \textit{which} prompts are selected, not \textit{how} operators process them.
\end{enumerate}

The rationale for this design is that operators should remain general-purpose prompt perturbation mechanisms, while speciation controls diversity through parent selection and population management. This separation of concerns keeps the operator suite reusable and maintains compatibility with ToxSearch.

\subsubsection{Operator Scheduling and Routing}

The system uses \textbf{fixed operator allocation} with no per-species routing or adaptive allocation:

\begin{enumerate}
    \item \textbf{Fixed allocation}: All operators are applied to all selected parents with equal frequency. There is no per-species operator scheduling or adaptive allocation based on species characteristics.
    
    \item \textbf{Operator effectiveness tracking}: Operator effectiveness is tracked per operator across all species (not per species-operator combination). Metrics include:
    \begin{itemize}
        \item NE (Number of Elites): Number of variants that become elites
        \item EHR (Elite Hit Rate): Fraction of variants that become elites
        \item IR (Improvement Rate): Fraction of variants that improve parent fitness
        \item $\Delta\mu$: Mean fitness change
        \item $\Delta\sigma$: Fitness variance change
    \end{itemize}
    
    \item \textbf{No adaptive routing}: The system does not adaptively route operators to specific species based on effectiveness. All species receive the same operator suite, ensuring fair exploration across niches.
\end{enumerate}

This fixed allocation approach ensures that:
\begin{itemize}
    \item All species have equal access to all operators
    \item Operator effectiveness can be analyzed across the entire population
    \item The system remains simple and interpretable
\end{itemize}

Future work could explore adaptive operator allocation per species, but the current implementation prioritizes simplicity and fairness.

\subsubsection{Operator Invariants}

All operators preserve the following invariants:

\begin{enumerate}
    \item \textbf{Question-form preservation}: Operators maintain the question format of prompts. Generated variants are still valid questions (ending with "?" or question words). This is enforced through:
    \begin{itemize}
        \item LLM-based operators use question-format prompts in their generation templates
        \item Text-based operators (synonym, antonym) preserve sentence structure
        \item Validation checks ensure output is question-form
    \end{itemize}
    
    \item \textbf{Language constraints}: Operators maintain language constraints (English prompts remain English). This is enforced through:
    \begin{itemize}
        \item LLM-based operators use English-only generation instructions
        \item Back-translation operators (Hindi) ensure round-trip translation quality
        \item Text-based operators operate on English text only
    \end{itemize}
    
    \item \textbf{Semantic coherence}: Operators maintain semantic coherence (variants remain semantically related to parents). This is enforced through:
    \begin{itemize}
        \item Semantic similarity operators (paraphrasing, synonym) preserve meaning
        \item Crossover operators combine semantically similar elements
        \item Validation checks ensure variants are not completely unrelated to parents
    \end{itemize}
    
    \item \textbf{Length constraints}: Operators maintain reasonable prompt length (not too short or too long). This is enforced through:
    \begin{itemize}
        \item LLM-based operators include length constraints in generation prompts
        \item Text-based operators preserve sentence length
        \item Validation checks filter extremely short or long variants
    \end{itemize}
\end{enumerate}

These invariants ensure that generated variants are valid, coherent prompts that can be meaningfully evaluated and compared. Violations of these invariants result in variant rejection (empty variants are not saved to \texttt{temp.json}).

Implementation: Invariant enforcement is handled within each operator's \texttt{apply()} method, with validation checks and error handling. Failed operator applications return empty variant lists, which are tracked as rejections in operator statistics.

\subsection{Parent Selection}

\subsubsection{Selection Modes and Mode Switching}

The system uses three adaptive selection modes that switch based on evolution progress:

\begin{enumerate}
    \item \textbf{DEFAULT mode}: Random species selection, then random parents from that species. Used for balanced exploration and exploitation.
    
    \item \textbf{EXPLOITATION mode}: Top species selection (highest fitness), then 3 parents from same species. Used for intensive local search around best regions.
    
    \item \textbf{EXPLORATION mode}: Multiple species selection (top + 2 random different species), then 3 parents from 3 different species. Used for cross-species exploration and diversity maintenance.
\end{enumerate}

Mode switching is triggered by the following logic:
\begin{equation}
\label{eq:mode_switching}
\text{mode} = \begin{cases}
\text{DEFAULT} & \text{if } g \leq 5 \text{ (early generations)} \\
\text{EXPLOITATION} & \text{if } \frac{\Delta f}{\Delta g} \leq 0.00 \text{ (no improvement or declining)} \\
\text{EXPLORATION} & \text{if } \text{stagnation} \geq 5 \text{ (stagnation detected)} \\
\text{DEFAULT} & \text{otherwise}
\end{cases}
\end{equation}
where $g$ is the generation number, $\Delta f / \Delta g$ is the fitness change rate, and $\text{stagnation}$ is the number of generations without fitness improvement.

Implementation: Mode switching logic is in \texttt{src/utils/adaptive\_selection.py} via \texttt{update\_adaptive\_selection\_logic()}, which analyzes \texttt{EvolutionTracker.json} to determine the current selection mode.

\subsubsection{Species-Aware Selection Differences from ToxSearch}

Parent selection differs from ToxSearch in the following ways:

\begin{enumerate}
    \item \textbf{Species structure}: Selection operates on species structure (elites grouped by species) rather than a flat population list. This enables species-aware selection that considers species boundaries.
    
    \item \textbf{Same-species exploitation}: In DEFAULT and EXPLOITATION modes, parents are selected from the same species, enabling local search within niches. This differs from ToxSearch, which selected parents globally without species consideration.
    
    \item \textbf{Cross-species exploration}: In EXPLORATION mode, parents are selected from different species, enabling exploration across species boundaries. This is a new capability not present in ToxSearch.
    
    \item \textbf{Cluster 0 inclusion}: Cluster 0 (reserves) is always included in selection, ensuring outliers have a chance to be selected. This prevents complete exclusion of potentially valuable outliers.
\end{enumerate}

The species-aware selection enables:
\begin{itemize}
    \item Controlled exploitation within species (maintaining niche quality)
    \item Controlled exploration across species (discovering new niches)
    \item Balanced diversity maintenance (preventing single-species dominance)
\end{itemize}

Implementation: Species-aware selection is in \texttt{src/ea/parent\_selector.py} via \texttt{adaptive\_tournament\_selection()}, which loads speciation state and groups genomes by species before selection.

\subsubsection{Species Starvation Prevention}

The system prevents "species starvation" (small species never being selected) through:

\begin{enumerate}
    \item \textbf{All active species eligible}: All active (non-frozen) species are eligible for selection, regardless of size. Small species have equal probability of being selected in DEFAULT mode (random species selection).
    
    \item \textbf{Cluster 0 always included}: Cluster 0 (reserves) is always included in selection, ensuring outliers are not completely excluded. This is particularly important for newly formed species that may start small.
    
    \item \textbf{No size-based exclusion}: Species are not excluded from selection based on size. Even species with 1 member can be selected (though they may require fallback logic if insufficient parents are available).
    
    \item \textbf{Fallback mechanisms}: If a selected species has insufficient members for the required number of parents, the system falls back to:
    \begin{itemize}
        \item Selecting from all genomes (if species has 1 member but 2 parents needed)
        \item Reusing parents (if species has 2 members but 3 parents needed)
        \item Selecting from cluster 0 as supplement
    \end{itemize}
\end{enumerate}

These mechanisms ensure that:
\begin{itemize}
    \item Small species are not permanently excluded from evolution
    \item New species have a chance to grow
    \item Diversity is maintained across all species sizes
\end{itemize}

Implementation: Starvation prevention is handled in \texttt{src/ea/parent\_selector.py} via fallback logic in \texttt{\_select\_parents\_default()}, \texttt{\_select\_parents\_exploitation()}, and \texttt{\_select\_parents\_exploration()}.

\subsubsection{Parent Count and Variant Generation}

The number of parents and resulting variant counts are:

\begin{enumerate}
    \item \textbf{DEFAULT mode}: 2 parents per selection, 11 iterations per generation
    \begin{equation}
    \label{eq:default_variants}
    N_{variants} = 11 \times 2 = 22 \text{ variants}
    \end{equation}
    Each iteration selects 2 parents from the same species, applies all operators, and generates variants.
    
    \item \textbf{EXPLOITATION mode}: 3 parents per selection, 12 iterations per generation
    \begin{equation}
    \label{eq:exploitation_variants}
    N_{variants} = 12 \times 3 = 36 \text{ variants}
    \end{equation}
    Each iteration selects 3 parents from the same top species, applies all operators, and generates variants.
    
    \item \textbf{EXPLORATION mode}: 3 parents per selection (from 3 different species), 12 iterations per generation
    \begin{equation}
    \label{eq:exploration_variants}
    N_{variants} = 12 \times 3 = 36 \text{ variants}
    \end{equation}
    Each iteration selects 3 parents from 3 different species, applies all operators, and generates variants.
\end{enumerate}

The rationale for 2-parent vs 3-parent regimes:
\begin{itemize}
    \item \textbf{2-parent (DEFAULT)}: Enables standard crossover (2 parents) and efficient mutation (1 parent). Balanced for general exploration.
    \item \textbf{3-parent (EXPLOITATION/EXPLORATION)}: Enables more intensive search (3 parents for crossover combinations) and higher variant diversity. Used when focused search is needed (exploitation) or cross-species exploration is desired (exploration).
\end{itemize}

The variant counts (22 vs 36) reflect the trade-off between exploration efficiency (fewer variants, faster generations) and search intensity (more variants, better coverage). The system adaptively switches between these regimes based on evolution progress.

\subsection{Population Management and Replacement}

\subsubsection{Population Structure and QD Alignment}

The population structure is designed to align with quality-diversity optimization:

\begin{equation}
\label{eq:population_structure}
P = E \cup R, \quad E = \bigcup_{i=1}^{k} S_i, \quad R = \text{Cluster 0}
\end{equation}
where:
\begin{itemize}
    \item $P$: Total population
    \item $E$: Elites (all species members)
    \item $S_i$: Species $i$ (semantically coherent niche)
    \item $R$: Reserves (cluster 0, outliers and incubator species)
\end{itemize}

This structure is QD-aligned because:
\begin{enumerate}
    \item \textbf{Multiple niches}: Each species $S_i$ represents a distinct niche (semantic + behavioral similarity), enabling coverage of multiple regions of the fitness landscape.
    
    \item \textbf{Quality preservation}: Each species maintains its best members (leaders) and high-fitness individuals, ensuring quality is preserved across niches.
    
    \item \textbf{Diversity maintenance}: Species are kept distinct through distance-based clustering, ensuring inter-species diversity is maintained.
    
    \item \textbf{Overflow buffer}: Cluster 0 serves as an overflow buffer for outliers and small species, preventing loss of potentially valuable diversity.
\end{enumerate}

This structure differs from ToxSearch, which used a flat population list without explicit niche organization.

\subsubsection{Capacity Constraints and Overflow Handling}

The system enforces capacity constraints to prevent unbounded population growth:

\begin{enumerate}
    \item \textbf{Per-species capacity}: Each species $S_i$ has a maximum capacity:
    \begin{equation}
    \label{eq:species_capacity}
    |S_i| \leq C_{species} = 100
    \end{equation}
    When a species exceeds capacity, the lowest-fitness members are removed (fitness-based trimming).
    
    \item \textbf{Cluster 0 capacity}: Cluster 0 (reserves) has a maximum capacity:
    \begin{equation}
    \label{eq:cluster0_capacity}
    |R| \leq C_{cluster0} = 1000
    \end{equation}
    When cluster 0 exceeds capacity, the lowest-fitness members are removed.
    
    \item \textbf{Overflow handling}: Overflow members (removed due to capacity) are handled as follows:
    \begin{itemize}
        \item \textbf{Archived}: Overflow members are saved to \texttt{archive.json} for potential future analysis
        \item \textbf{Not discarded}: Overflow members are not permanently lost; they are preserved in the archive
        \item \textbf{Reintroduction possible}: Archived members could potentially be reintroduced if needed (not currently implemented)
    \end{itemize}
\end{enumerate}

The capacity constraints ensure:
\begin{itemize}
    \item Computational efficiency (bounded population size)
    \item Quality focus (only high-fitness members retained)
    \item Diversity preservation (multiple species maintained)
\end{itemize}

Implementation: Capacity enforcement is in \texttt{src/speciation/capacity.py} via \texttt{enforce\_species\_capacity()} and \texttt{enforce\_cluster0\_capacity()}, which trim populations to capacity limits using fitness-based sorting.

\subsubsection{Removal Rules When Capacity Exceeded}

When capacity is exceeded, members are removed using the following rule:

\begin{equation}
\label{eq:removal_rule}
\text{Remove } p \text{ if } f(p) = \min_{p' \in S_i} f(p') \text{ and } |S_i| > C_{species}
\end{equation}

That is, the \textbf{lowest-fitness members} are removed first when capacity is exceeded. This rule ensures:
\begin{enumerate}
    \item \textbf{Quality preservation}: High-fitness members are retained, maintaining species quality
    \item \textbf{Fair removal}: Removal is based on objective fitness, not arbitrary criteria
    \item \textbf{Elite preservation}: Species leaders (highest-fitness members) are never removed due to capacity
\end{enumerate}

The removal process:
\begin{enumerate}
    \item Sort species members by fitness (descending)
    \item Keep top $C_{species}$ members
    \item Remove remaining members (lowest fitness)
    \item Archive removed members to \texttt{archive.json}
\end{enumerate}

This differs from alternative removal rules:
\begin{itemize}
    \item \textbf{Age-based}: Would remove oldest members, but age may not correlate with fitness
    \item \textbf{Random}: Would remove random members, but this could remove high-fitness members
    \item \textbf{Diversity-based}: Would remove most similar members, but this is complex and may remove valuable members
\end{itemize}

The fitness-based removal rule is simple, effective, and aligns with the quality-diversity objective (preserving high-quality solutions).

\subsubsection{Deduplication Stages and Importance}

The system performs two-stage deduplication to prevent duplicate variants:

\begin{enumerate}
    \item \textbf{Intra-temp deduplication}: Removes exact duplicates within \texttt{temp.json} (current generation's variants). This prevents the same variant from being evaluated multiple times in a single generation.
    
    \item \textbf{Population-wide deduplication}: Removes duplicates against the entire population (elites + reserves). This prevents variants that already exist in the population from being re-evaluated.
\end{enumerate}

Deduplication is performed using exact prompt text matching:
\begin{equation}
\label{eq:deduplication}
\text{duplicate}(p_1, p_2) = \begin{cases}
\text{True} & \text{if } \text{prompt}(p_1) = \text{prompt}(p_2) \text{ (exact match)} \\
\text{False} & \text{otherwise}
\end{cases}
\end{equation}

Deduplication is critical for diversity claims because:
\begin{enumerate}
    \item \textbf{Prevents duplicate evaluation}: Duplicate variants would consume API calls without adding diversity
    \item \textbf{Maintains diversity metrics}: Duplicate variants would artificially inflate population size without increasing actual diversity
    \item \textbf{Ensures fair comparison}: Deduplication ensures that diversity metrics (inter/intra-species diversity) reflect actual distinctness, not duplicate inflation
    \item \textbf{Query efficiency}: Deduplication prevents wasteful API calls on variants that have already been evaluated
\end{enumerate}

Implementation: Deduplication is in \texttt{src/utils/population\_io.py} via \texttt{deduplicate\_variants()}, which performs both intra-temp and population-wide deduplication using exact text matching.

\subsection{Speciation Module}
\label{sec:speciation_module}

\subsubsection{Clustered Objects and Frequency}

The speciation module clusters the following objects:

\begin{enumerate}
    \item \textbf{Prompt genomes} (genotype): The text prompts themselves, represented as semantic embeddings $e \in \mathbb{R}^{384}$ (L2-normalized). These embeddings capture semantic similarity between prompts.
    
    \item \textbf{Response score vectors} (phenotype): 8-dimensional vectors $p \in [0,1]^8$ extracted from moderation oracle responses. These vectors capture behavioral similarity (how similarly the LLM responds to different prompts).
\end{enumerate}

The clustering uses an \textbf{ensemble} of both genotype and phenotype, combining them via the ensemble distance metric (Equation~\ref{eq:ensemble_distance}).

Clustering is performed \textbf{every generation} after evaluation. This frequency ensures:
\begin{itemize}
    \item New variants are immediately assigned to species or cluster 0
    \item Species structure is continuously updated as the population evolves
    \item Species leaders are updated when higher-fitness members join
    \item Species merging and extinction are processed promptly
\end{itemize}

The clustering frequency is fixed (not adaptive) to maintain consistency and enable incremental clustering. Implementation: Clustering is called in \texttt{src/speciation/run\_speciation.py} via \texttt{process\_generation()}, which is invoked every generation after evaluation.

\subsubsection{Similarity Space and Distances}

The similarity space is defined by:

\begin{enumerate}
    \item \textbf{Embedding model}: \texttt{all-MiniLM-L6-v2} (sentence-transformer model)
    \begin{itemize}
        \item Dimensionality: 384 dimensions
        \item Normalization: L2-normalized embeddings $e \in \mathbb{R}^{384}$ with $\|e\|_2 = 1$
        \item Semantic representation: Captures semantic meaning of prompts
    \end{itemize}
    
    \item \textbf{Phenotype extraction}: 8-dimensional response score vectors $p \in [0,1]^8$
    \begin{itemize}
        \item Extracted from \texttt{moderation\_result.google.scores}
        \item Fixed order: [toxicity, threat, profanity, sexually\_explicit, identity\_attack, flirtation, insult, severe\_toxicity]
        \item Behavioral representation: Captures how the LLM responds to prompts
    \end{itemize}
\end{enumerate}

The distance metrics are:

\begin{enumerate}
    \item \textbf{Genotype distance} (semantic):
    \begin{equation}
    \label{eq:genotype_distance_detail}
    d_{genotype}(u, v) = 1 - (e_u \cdot e_v)
    \end{equation}
    where $e_u, e_v \in \mathbb{R}^{384}$ are L2-normalized embeddings. For normalized vectors, $e_u \cdot e_v$ is the cosine similarity, so $d_{genotype}$ is the cosine distance. Range: $[0, 2]$ where 0 = identical, 2 = maximally different.
    
    \item \textbf{Phenotype distance} (behavioral):
    \begin{equation}
    \label{eq:phenotype_distance_detail}
    d_{phenotype}(u, v) = \frac{\|p_u - p_v\|_2}{\sqrt{8}}
    \end{equation}
    where $p_u, p_v \in [0,1]^8$ are response score vectors, and $\sqrt{8}$ is the normalization factor (maximum possible Euclidean distance in 8D unit cube). Range: $[0, 1]$.
    
    \item \textbf{Ensemble distance} (combined):
    \begin{equation}
    \label{eq:ensemble_distance_detail}
    d_{ensemble}(u, v) = w_{genotype} \times d_{genotype\_norm}(u, v) + w_{phenotype} \times d_{phenotype}(u, v)
    \end{equation}
    where $d_{genotype\_norm} = d_{genotype} / 2.0$ normalizes genotype distance to $[0, 1]$, and $w_{genotype} = 0.7$, $w_{phenotype} = 0.3$ are the ensemble weights. Range: $[0, 1]$.
\end{enumerate}

The ensemble distance combines semantic and behavioral similarity, enabling more accurate species assignment than either metric alone. Implementation: Distance computation is in \texttt{src/speciation/distance.py} and \texttt{src/speciation/phenotype\_distance.py}.

\subsubsection{Clustering Algorithm: Leader-Follower}

The system uses the \textbf{Leader-Follower} clustering algorithm, an incremental clustering method:

\begin{enumerate}
    \item \textbf{Incremental assignment}: For each new variant, compute ensemble distance to all existing species leaders. If distance $< \theta_{sim} = 0.2$, assign to that species.
    
    \item \textbf{Cluster 0 check}: If variant doesn't fit any existing species, check against cluster 0 outliers (potential leaders). If distance $< \theta_{sim}$, add as follower (tracked but no species yet).
    
    \item \textbf{Deferred species ID assignment}: Species IDs are only assigned when a leader gains enough followers to reach \texttt{min\_island\_size} (default: 2). This ensures:
    \begin{itemize}
        \item No wasted species IDs
        \item No species smaller than \texttt{min\_island\_size}
        \item Species inherently have minimum size
    \end{itemize}
    
    \item \textbf{New species formation}: If variant doesn't fit any leader or outlier, it becomes a new potential leader in cluster 0. When it gains enough followers, a new species forms.
    
    \item \textbf{Leader updates}: When a new member joins a species, if $f(p_{new}) > f(\text{leader}(S_i))$, the new member becomes the leader. Leader embedding and phenotype are updated.
\end{enumerate}

The assignment criteria are:
\begin{equation}
\label{eq:assignment_criteria}
p \in S_i \text{ if } d_{ensemble}(p, \text{leader}(S_i)) < \theta_{sim} = 0.2
\end{equation}

The merge criteria are:
\begin{equation}
\label{eq:merge_criteria}
\text{Merge } S_i, S_j \text{ if } d_{ensemble}(\text{leader}(S_i), \text{leader}(S_j)) < \theta_{merge} = 0.1 \text{ and both stable } (\geq 3 \text{ generations})
\end{equation}

Implementation: Leader-Follower clustering is in \texttt{src/speciation/leader\_follower.py} via \texttt{leader\_follower\_clustering()}, which reads \texttt{temp.json} and \texttt{speciation\_state.json}, performs clustering, and updates both files.

\subsubsection{Species Leader Definition and Updates}

The species leader is defined as:

\begin{equation}
\label{eq:leader_definition_detail}
\text{leader}(S_i) = \arg\max_{p \in S_i} f(p)
\end{equation}

That is, the leader is the individual with the highest fitness in the species. The leader serves as:
\begin{itemize}
    \item \textbf{Species representative}: Defines the species center for distance computations
    \item \textbf{Quality indicator}: Represents the best quality achieved by the species
    \item \textbf{Clustering anchor}: New variants are assigned to species based on distance to leader
\end{itemize}

Leader updates occur when:
\begin{enumerate}
    \item A new member joins the species with higher fitness than the current leader
    \item The leader is removed (due to capacity or extinction), and a new leader is selected from remaining members
\end{enumerate}

When a leader is updated:
\begin{itemize}
    \item The new leader's embedding and phenotype become the species center
    \item Species radius is verified (members outside radius are moved to cluster 0)
    \item Leader fitness history is updated
    \item Stagnation counter is reset (if fitness improved)
\end{itemize}

Implementation: Leader updates are handled in \texttt{src/speciation/leader\_follower.py} during clustering, and in \texttt{src/speciation/capacity.py} during capacity enforcement.

\subsubsection{Stagnation Handling}

Species stagnation is handled as follows:

\begin{enumerate}
    \item \textbf{Stagnation tracking}: For each species $S_i$, track the number of generations without fitness improvement:
    \begin{equation}
    \label{eq:stagnation_tracking}
    \text{stagnation}(S_i) = \begin{cases}
    \text{stagnation}(S_i) + 1 & \text{if } f(\text{leader}(S_i))_{t+1} = f(\text{leader}(S_i))_t \\
    0 & \text{if } f(\text{leader}(S_i))_{t+1} > f(\text{leader}(S_i))_t
    \end{cases}
    \end{equation}
    
    \item \textbf{Freezing}: If $\text{stagnation}(S_i) \geq 20$ generations, the species is frozen (moved to "frozen" state). Frozen species:
    \begin{itemize}
        \item Are excluded from parent selection
        \item Are preserved in \texttt{speciation\_state.json} for reference
        \item Can be reactivated if a new member with higher fitness joins
    \end{itemize}
    
    \item \textbf{Small species handling}: If $|S_i| < 2$ (below \texttt{min\_island\_size}), the species is moved to cluster 0 (incubator state). This prevents tiny species from fragmenting the population.
    
    \item \textbf{Merging}: Similar species (leader distance $< \theta_{merge}$) are merged to prevent excessive fragmentation. Merged species combine members, keep highest-fitness leader, and reset stagnation.
\end{enumerate}

The rationale for these mechanisms is:
\begin{itemize}
    \item \textbf{Freezing}: Prevents wasted computation on stagnant species while preserving them for analysis
    \item \textbf{Small species handling}: Prevents population fragmentation while allowing small species to grow in cluster 0
    \item \textbf{Merging}: Prevents excessive species proliferation while maintaining diversity
\end{itemize}

Implementation: Stagnation handling is in \texttt{src/speciation/extinction.py} via \texttt{process\_extinctions()}, which freezes stagnant species and moves small species to cluster 0.

\subsubsection{Behavioral Meaning of Species}

A "species" in this system represents an \textbf{ensemble niche} that combines:

\begin{enumerate}
    \item \textbf{Semantic niche}: Prompts in the same species are semantically similar (similar embeddings). This captures similarity in prompt content, structure, and meaning.
    
    \item \textbf{Response-profile niche}: Prompts in the same species elicit similar responses from the LLM (similar phenotype vectors). This captures similarity in how the LLM behaves when given these prompts.
    
    \item \textbf{Ensemble niche}: The combination of semantic and behavioral similarity via ensemble distance. This ensures species are distinct in both prompt space and response space.
\end{enumerate}

The behavioral meaning is that species represent \textbf{distinct attack strategies}:
\begin{itemize}
    \item Each species explores a different region of the prompt space
    \item Each species targets a different vulnerability or attack vector
    \item Species maintain diversity across both prompt semantics and LLM responses
\end{itemize}

This ensemble niche definition ensures that:
\begin{itemize}
    \item Species are meaningfully distinct (not just semantically similar but also behaviorally similar)
    \item The QD archive covers diverse attack strategies (both in prompt space and response space)
    \item Quality-diversity optimization maintains coverage across multiple dimensions
\end{itemize}

\subsection{Quality-Diversity Outputs and Tracking}

\subsubsection{QD Artifact Produced}

The system produces a \textbf{multi-species QD archive} as its primary output:

\begin{equation}
\label{eq:qd_artifact}
\mathcal{A} = \bigcup_{i=1}^{k} \{\text{leader}(S_i)\} \cup \{p \in S_i : f(p) \geq \alpha \times \text{quality}(S_i)\}
\end{equation}
where $\alpha \in [0, 1]$ is a quality threshold (typically $\alpha = 0.9$).

The QD archive contains:
\begin{enumerate}
    \item \textbf{Per-species best prompts}: The leader of each species (highest-fitness member)
    \item \textbf{High-quality solutions}: All members with fitness $\geq 0.9 \times \text{leader fitness}$ within each species
    \item \textbf{Species metadata}: Species labels (c-TF-IDF top 10 words), fitness history, size, origin
\end{enumerate}

The archive is stored in:
\begin{itemize}
    \item \texttt{elites.json}: All species members (elites)
    \item \texttt{speciation\_state.json}: Species structure and metadata
    \item \texttt{archive.json}: Overflow members (non-elites removed due to capacity)
\end{itemize}

This archive enables:
\begin{itemize}
    \item Systematic red-teaming coverage (multiple distinct attack strategies)
    \item Quality-diversity analysis (trade-off between quality and diversity)
    \item Reproducibility (archive can be re-evaluated or analyzed)
\end{itemize}

\subsubsection{Diversity Signals Tracked}

The system tracks the following diversity signals:

\begin{enumerate}
    \item \textbf{Species count}: $K = |\{S_i : \text{state}(S_i) = \text{active}\}|$ (number of active species)
    
    \item \textbf{Species size distribution}: $|S_i|$ for each species $S_i$, tracked as:
    \begin{itemize}
        \item Mean species size: $\mu_{size} = \frac{1}{K} \sum_{i=1}^{k} |S_i|$
        \item Size variance: $\sigma^2_{size} = \frac{1}{K} \sum_{i=1}^{k} (|S_i| - \mu_{size})^2$
        \item Size histogram: Distribution of species sizes
    \end{itemize}
    
    \item \textbf{Inter-species diversity}: $D_{inter}$ as defined in Equation~\ref{eq:inter_diversity}, computed from species leaders
    
    \item \textbf{Intra-species diversity}: $D_{intra}(S_i)$ as defined in Equation~\ref{eq:intra_diversity}, computed for each species
    
    \item \textbf{Cluster 0 size}: $|R|$ (number of outliers in reserves)
\end{enumerate}

These signals are tracked each generation and persisted to \texttt{EvolutionTracker.json} and \texttt{speciation\_state.json} for analysis.

\subsubsection{Operator-Species Telemetry for RQ1}

To enable RQ1 (operator effectiveness changes under speciation), the system tracks operator telemetry:

\begin{enumerate}
    \item \textbf{Per-operator effectiveness metrics}:
    \begin{itemize}
        \item NE (Number of Elites): Number of variants that become elites
        \item EHR (Elite Hit Rate): Fraction of variants that become elites
        \item IR (Improvement Rate): Fraction of variants that improve parent fitness
        \item $\Delta\mu$: Mean fitness change (average fitness improvement)
        \item $\Delta\sigma$: Fitness variance change (diversity impact)
    \end{itemize}
    
    \item \textbf{Operator effectiveness across species}: Metrics are tracked per operator across all species (not per species-operator combination), enabling analysis of:
    \begin{itemize}
        \item Which operators are most effective overall
        \item How operator effectiveness changes as speciation evolves
        \item Whether certain operators favor certain species types
    \end{itemize}
    
    \item \textbf{Operator statistics persistence}: All operator telemetry is persisted to \texttt{EvolutionTracker.json} each generation, enabling:
    \begin{itemize}
        \item Longitudinal analysis of operator effectiveness
        \item Comparison of operator performance across generations
        \item Identification of operator effectiveness trends
    \end{itemize}
\end{enumerate}

This telemetry enables answering RQ1 by comparing operator effectiveness in the speciated system vs. the original ToxSearch system.

\subsubsection{Cluster Quality Telemetry for RQ2}

To enable RQ2 (cluster quality metrics), the system tracks:

\begin{enumerate}
    \item \textbf{Inter/intra-species diversity}: As defined in Equations~\ref{eq:inter_diversity} and \ref{eq:intra_diversity}, these metrics measure:
    \begin{itemize}
        \item Inter-species diversity: How distinct species are from each other
        \item Intra-species diversity: How cohesive species are internally
    \end{itemize}
    
    \item \textbf{Species fitness distributions}: For each species $S_i$:
    \begin{itemize}
        \item Mean fitness: $\mu_{fitness}(S_i) = \frac{1}{|S_i|} \sum_{p \in S_i} f(p)$
        \item Max fitness: $\max_{p \in S_i} f(p)$ (leader fitness)
        \item Fitness variance: $\sigma^2_{fitness}(S_i)$
        \item Fitness histogram: Distribution of fitness within species
    \end{itemize}
    
    \item \textbf{Merge/extinction events}: Tracked as:
    \begin{itemize}
        \item Merge events: Which species merged, when, resulting species ID
        \item Extinction events: Which species were frozen, when, reason
        \item Split events: When cluster 0 forms new species
    \end{itemize}
    
    \item \textbf{Species stability}: For each species $S_i$:
    \begin{itemize}
        \item Age: Generations since species creation
        \item Stagnation: Generations without fitness improvement
        \item Size stability: How size changes over time
    \end{itemize}
\end{enumerate}

These metrics enable answering RQ2 by evaluating cluster quality through:
\begin{itemize}
    \item Diversity metrics (inter/intra-species diversity)
    \item Fitness metrics (species fitness distributions)
    \item Stability metrics (merge/extinction events, species age)
\end{itemize}

All cluster quality telemetry is persisted to \texttt{speciation\_state.json} and \texttt{EvolutionTracker.json} for analysis.

\subsection{Implementation Notes and Reproducibility}

\subsubsection{Key Hyperparameters}

The system's key hyperparameters are listed in Table~\ref{tab:hyperparameters}:

\begin{table}[h]
\centering
\caption{Key Hyperparameters for Enhanced ToxSearch with Speciation}
\label{tab:hyperparameters}
\begin{tabular}{lll}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Description} \\
\hline
$\theta_{sim}$ & 0.2 & Similarity threshold for species assignment (ensemble distance) \\
$\theta_{merge}$ & 0.1 & Merge threshold for combining similar species \\
$C_{species}$ & 100 & Maximum individuals per species \\
$C_{cluster0}$ & 1000 & Maximum individuals in cluster 0 \\
$\text{min\_island\_size}$ & 2 & Minimum species size before extinction \\
$\text{species\_stagnation}$ & 20 & Maximum generations without improvement before freezing \\
$w_{genotype}$ & 0.7 & Weight for genotype distance in ensemble distance \\
$w_{phenotype}$ & 0.3 & Weight for phenotype distance in ensemble distance \\
$\text{embedding\_model}$ & all-MiniLM-L6-v2 & Sentence-transformer model for embeddings \\
$\text{embedding\_dim}$ & 384 & Embedding dimensionality \\
$\text{embedding\_batch\_size}$ & 64 & Batch size for embedding computation \\
$\text{adaptive\_selection\_after}$ & 5 & Generations before adaptive selection activates \\
$\text{stagnation\_limit}$ & 5 & Generations of stagnation before EXPLORATION mode \\
\hline
\end{tabular}
\end{table}

These hyperparameters are defined in \texttt{src/speciation/config.py} via the \texttt{SpeciationConfig} dataclass, and can be configured via command-line arguments in \texttt{src/main.py}.

\subsubsection{Randomness Sources and Seed Handling}

The system has the following randomness sources:

\begin{enumerate}
    \item \textbf{PG sampling}: LLM generation for prompt variants (stochastic decoding)
    \begin{itemize}
        \item Temperature: Controlled by LLM configuration (typically 0.7--1.0)
        \item Seed: Not directly controllable (LLM internal randomness)
    \end{itemize}
    
    \item \textbf{RG sampling}: LLM generation for responses (stochastic decoding)
    \begin{itemize}
        \item Temperature: Controlled by LLM configuration (typically 0.7--1.0)
        \item Seed: Not directly controllable (LLM internal randomness)
    \end{itemize}
    
    \item \textbf{Selection randomness}: Parent selection uses random sampling
    \begin{itemize}
        \item Species selection: Random choice from active species (DEFAULT mode)
        \item Parent selection: Random sampling from selected species
        \item Python \texttt{random} module: Uses system RNG (can be seeded)
    \end{itemize}
    
    \item \textbf{Operator randomness}: Some operators use random sampling
    \begin{itemize}
        \item Synonym/antonym replacement: Random word selection
        \item Typographical errors: Random character swaps
        \item Crossover: Random element selection
    \end{itemize}
\end{enumerate}

Seed handling:
\begin{itemize}
    \item \textbf{Python RNG}: Can be seeded via \texttt{random.seed()} for reproducibility
    \item \textbf{LLM randomness}: Not directly seedable (LLM internal), but can be controlled via temperature
    \item \textbf{Reproducibility}: Full reproducibility requires fixing all randomness sources, which is challenging due to LLM stochasticity
\end{itemize}

For practical reproducibility, the system persists all state to disk, enabling:
\begin{itemize}
    \item State restoration after interruptions
    \item Re-evaluation of archived prompts
    \item Analysis of evolution history
\end{itemize}

\subsubsection{Persistence to Disk per Generation}

The system persists the following artifacts to disk each generation:

\begin{enumerate}
    \item \textbf{Speciation state}: \texttt{speciation\_state.json}
    \begin{itemize}
        \item Species structure (leaders, members, fitness history)
        \item Cluster 0 (outliers and potential leaders)
        \item Merge/extinction events
        \item Species labels (c-TF-IDF)
    \end{itemize}
    
    \item \textbf{Population files}:
    \begin{itemize}
        \item \texttt{elites.json}: All genomes with \texttt{species\_id > 0} (species members)
        \item \texttt{reserves.json}: All genomes with \texttt{species\_id = 0} (cluster 0 outliers)
        \item \texttt{archive.json}: Overflow genomes (removed due to capacity)
        \item \texttt{temp.json}: Current generation's variants (cleared after speciation)
    \end{itemize}
    
    \item \textbf{Evolution tracker}: \texttt{EvolutionTracker.json}
    \begin{itemize}
        \item Generation statistics (elites count, reserves count, average fitness)
        \item Operator effectiveness metrics (NE, EHR, IR, $\Delta\mu$, $\Delta\sigma$)
        \item Speciation metrics (species count, inter/intra-species diversity)
        \item Refusal statistics (refusals detected, penalties applied)
    \end{itemize}
    
    \item \textbf{Log files}: \texttt{logs/evolution.log}
    \begin{itemize}
        \item Generation-by-generation evolution log
        \item Operator application logs
        \item Speciation processing logs
        \item Error and warning messages
    \end{itemize}
\end{enumerate}

This persistence enables:
\begin{itemize}
    \item \textbf{Reproducibility}: All state is saved, enabling exact reproduction of evolution runs
    \item \textbf{Auditability}: All decisions and events are logged, enabling post-hoc analysis
    \item \textbf{Resumability}: Evolution can be resumed from any generation by loading state
    \item \textbf{Analysis}: Historical data enables longitudinal analysis of evolution dynamics
\end{itemize}

Implementation: Persistence is handled in \texttt{src/speciation/run\_speciation.py} (speciation state), \texttt{src/utils/population\_io.py} (population files), and \texttt{src/main.py} (evolution tracker and logs).
