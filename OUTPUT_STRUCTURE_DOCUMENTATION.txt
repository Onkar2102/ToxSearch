================================================================================
OUTPUT STRUCTURE DOCUMENTATION
================================================================================

This document describes the structure, calculation, update timing, and purpose
of all fields in EvolutionTracker.json and speciation_state.json.

================================================================================
SECTION 1: EvolutionTracker.json
================================================================================

EvolutionTracker.json tracks the overall evolution progress across all
generations. It contains global statistics, per-generation data, and cumulative
metrics.

--------------------------------------------------------------------------------
ROOT LEVEL FIELDS
--------------------------------------------------------------------------------

1. status
   Type: string
   Values: "not_complete", "complete"
   Calculation: Set to "not_complete" at initialization, "complete" when max_generations reached
   When Updated: 
     - Initialized in load_and_initialize_population() (population_io.py:704)
     - Updated in main.py when evolution completes
   Why: Tracks whether the evolution run has finished

2. total_generations
   Type: integer
   Calculation: Count of generations array length or max generation_number + 1
   When Updated: 
     - Initialized to 1 in load_and_initialize_population() (population_io.py:705)
     - Updated after each generation completes
   Why: Tracks total number of generations processed

3. generations_since_improvement
   Type: integer
   Calculation: Count of consecutive generations without fitness improvement
   When Updated: 
     - Updated in main.py after each generation when checking for improvement
     - Reset to 0 when improvement detected
   Why: Used for adaptive selection mode switching (EXPLOIT/EXPLORE triggers)

4. avg_fitness_history
   Type: array of floats
   Calculation: List of average fitness values per generation (from elites.json + reserves.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:1972)
     - Built from generations array, excluding placeholder 0.0 values
   Why: Tracks fitness trends over time for analysis and mode switching

5. slope_of_avg_fitness
   Type: float
   Calculation: Linear regression slope of avg_fitness_history over last N generations
   When Updated: 
     - Calculated in main.py after updating avg_fitness_history
   Why: Used to determine EXPLOIT/EXPLORE mode (negative slope = EXPLOIT, non-negative = EXPLORE)

6. selection_mode
   Type: string
   Values: "default", "exploitation", "exploration"
   Calculation: Determined by adaptive tournament selection logic based on fitness slope
   When Updated: 
     - Updated in main.py after mode switching logic
     - Initialized to "default" in load_and_initialize_population()
   Why: Tracks current parent selection strategy

7. generations
   Type: array of objects
   Description: Per-generation statistics (see GENERATION OBJECT FIELDS below)
   When Updated: 
     - New entry created for each generation
     - Updated in update_evolution_tracker_with_statistics() and update_evolution_tracker_with_speciation()
   Why: Detailed per-generation tracking for analysis

8. speciation_summary
   Type: object
   Description: Cumulative speciation statistics (see SPECIATION_SUMMARY FIELDS below)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:869)
     - Aggregated from all generations
   Why: Quick overview of speciation state

9. cumulative_budget
   Type: object
   Description: Cumulative computational costs (see CUMULATIVE_BUDGET FIELDS below)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2041-2056)
     - Accumulated across all generations
   Why: Track total computational resources used

10. population_max_toxicity
    Type: float
    Calculation: Maximum toxicity score found across all generations (from elites.json + reserves.json)
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2058-2064)
      - Only updated if new max > current max
    Why: Tracks best result achieved

--------------------------------------------------------------------------------
GENERATION OBJECT FIELDS (within generations array)
--------------------------------------------------------------------------------

1. generation_number
   Type: integer
   Calculation: Sequential generation number (0, 1, 2, ...)
   When Updated: Set when generation entry is created
   Why: Identifies the generation

2. genome_id
   Type: string or integer
   Calculation: ID of the best genome in this generation (highest fitness)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2067-2068)
     - Also set in check_threshold_and_update_tracker() (run_evolution.py:124)
   Why: Tracks the best individual per generation

3. max_score_variants
   Type: float
   Calculation: Maximum fitness score among variants created in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2022)
     - Calculated from temp.json genomes for current generation
   Why: Tracks best variant quality per generation

4. min_score_variants
   Type: float
   Calculation: Minimum fitness score among variants created in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2023)
     - Calculated from temp.json genomes for current generation
   Why: Tracks worst variant quality per generation

5. avg_fitness
   Type: float
   Calculation: Average fitness across all active population (elites.json + reserves.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2026)
     - Alias for avg_fitness_generation
   Why: Overall population fitness metric

6. avg_fitness_variants
   Type: float
   Calculation: Average fitness of variants created in this generation (from temp.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2024)
     - Calculated from temp.json genomes for current generation
   Why: Tracks average quality of new variants

7. avg_fitness_generation
   Type: float
   Calculation: Average fitness across all active population (elites.json + reserves.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2025)
     - Calculated via calculate_average_fitness() (population_io.py:1474)
   Why: Population-wide average fitness

8. avg_fitness_elites
   Type: float
   Calculation: Average fitness of genomes in elites.json (species_id > 0)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2027)
     - Calculated from elites.json
   Why: Tracks fitness of speciated genomes

9. avg_fitness_reserves
   Type: float
   Calculation: Average fitness of genomes in reserves.json (species_id = 0)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2028)
     - Calculated from reserves.json
   Why: Tracks fitness of outlier genomes

10. parents
    Type: array of strings or null
    Calculation: IDs of parent genomes used to create variants
    When Updated: 
      - Updated in evolution_engine.py after parent selection (evolution_engine.py:617-633)
      - Saved to parents.json and tracked in EvolutionTracker
    Why: Tracks parent selection for analysis

11. top_10
    Type: array of strings or null
    Calculation: IDs of top 10 genomes by fitness (from elites.json + reserves.json)
    When Updated: 
      - Updated in evolution_engine.py after fitness evaluation (evolution_engine.py:617-633)
      - Saved to top_10.json and tracked in EvolutionTracker
    Why: Tracks elite genomes for informed evolution operator

12. variants_created
    Type: integer
    Calculation: Total number of variants created in this generation
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2070-2071)
      - Counted from run_evolution() result
    Why: Tracks generation productivity

13. mutation_variants
    Type: integer
    Calculation: Number of variants created via mutation operators
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2072-2073)
      - Counted from run_evolution() result
    Why: Tracks mutation operator usage

14. crossover_variants
    Type: integer
    Calculation: Number of variants created via crossover operators
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2074-2075)
      - Counted from run_evolution() result
    Why: Tracks crossover operator usage

15. removal_threshold
    Type: float
    Calculation: Minimum fitness threshold for genome removal (default: 0.0001)
    When Updated: 
      - Set in check_threshold_and_update_tracker() (run_evolution.py:198)
      - Constant value
    Why: Tracks removal criteria

16. elites_count
    Type: integer
    Calculation: Number of genomes in elites.json (species_id > 0)
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2019)
      - Counted from elites.json
    Why: Tracks speciated population size

17. reserves_count
    Type: integer
    Calculation: Number of genomes in reserves.json (species_id = 0)
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2020)
      - Counted from reserves.json
    Why: Tracks outlier population size

18. total_population
    Type: integer
    Calculation: elites_count + reserves_count
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2021)
      - Calculated from elites.json + reserves.json
    Why: Total active population size

19. selection_mode
    Type: string
    Values: "default", "exploitation", "exploration"
    Calculation: Current parent selection mode
    When Updated: 
      - Updated in main.py after mode switching
      - Inherited from root level if not set
    Why: Tracks selection strategy for this generation

20. operator_statistics
    Type: object
    Description: Per-operator statistics (see OPERATOR_STATISTICS FIELDS below)
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2078-2079)
      - From run_evolution() result
    Why: Tracks operator effectiveness

21. speciation
    Type: object
    Description: Speciation metrics for this generation (see SPECIATION FIELDS below)
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:919)
      - After each speciation run
    Why: Tracks speciation state per generation

22. budget
    Type: object
    Description: Computational budget for this generation (see BUDGET FIELDS below)
    When Updated: 
      - Updated in update_evolution_tracker_with_statistics() (population_io.py:2032-2038)
      - Calculated via calculate_budget_metrics() (population_io.py:1536)
    Why: Tracks computational cost per generation

--------------------------------------------------------------------------------
OPERATOR_STATISTICS FIELDS (within operator_statistics object)
--------------------------------------------------------------------------------

Each operator has its own entry with:

1. duplicates_removed
   Type: integer
   Calculation: Number of duplicate variants removed for this operator
   When Updated: 
     - Counted in run_evolution() during deduplication
     - Updated in update_evolution_tracker_with_statistics()
   Why: Tracks operator efficiency (lower is better)

2. question_mark_rejections
   Type: integer
   Calculation: Number of variants rejected due to invalid responses (containing "?")
   When Updated: 
     - Counted in run_evolution() during validation
     - Updated in update_evolution_tracker_with_statistics()
   Why: Tracks operator quality (lower is better)

--------------------------------------------------------------------------------
SPECIATION FIELDS (within generation.speciation object)
--------------------------------------------------------------------------------

1. species_count
   Type: integer
   Calculation: Number of active species (from speciation_state.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:949)
     - From run_speciation() result
   Why: Tracks number of species

2. reserves_size
   Type: integer
   Calculation: Number of genomes in reserves.json (species_id = 0)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:950)
     - Read from reserves.json file (not cluster0.size)
   Why: Tracks outlier population size

3. speciation_events
   Type: integer
   Calculation: Number of new species created from reserves in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:951)
     - From run_speciation() result
   Why: Tracks speciation activity

4. merge_events
   Type: integer
   Calculation: Number of species merged in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:952)
     - From run_speciation() result
   Why: Tracks species consolidation

5. extinction_events
   Type: integer
   Calculation: Number of species frozen due to stagnation (NOT moved to cluster 0)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:953)
     - From run_speciation() result (extinction.py:99)
   Why: Tracks species extinction (frozen species only)

6. archived_count
   Type: integer
   Calculation: Number of genomes archived due to capacity limits
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:954)
     - From run_speciation() result
   Why: Tracks capacity enforcement

7. elites_moved
   Type: integer
   Calculation: Number of genomes moved to elites.json in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:955)
     - From distribute_genomes() result (run_speciation.py:437)
   Why: Tracks distribution activity

8. reserves_moved
   Type: integer
   Calculation: Number of genomes moved to reserves.json in this generation
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:956)
     - From distribute_genomes() result (run_speciation.py:438)
   Why: Tracks distribution activity

9. genomes_updated
   Type: integer
   Calculation: Number of genomes processed in speciation (from temp.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:957)
     - From run_speciation() result
   Why: Tracks speciation processing volume

10. inter_species_diversity
    Type: float
    Calculation: Average ensemble distance between species leaders
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:912)
      - Calculated via compute_diversity_metrics() (metrics.py:106)
    Why: Measures diversity between species (higher = more diverse)

11. intra_species_diversity
    Type: float
    Calculation: Average ensemble distance within each species
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:913)
      - Calculated via compute_diversity_metrics() (metrics.py:106)
    Why: Measures diversity within species (higher = more diverse)

12. total_population
    Type: integer
    Calculation: Sum of genomes in elites.json + reserves.json
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:914)
      - Calculated from actual files (not in-memory objects)
    Why: Accurate population count from source files

13. best_fitness
    Type: float
    Calculation: Maximum fitness across all genomes (elites.json + reserves.json)
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:915)
      - Calculated from actual files
    Why: Tracks best fitness in population

14. avg_fitness
    Type: float
    Calculation: Average fitness across all genomes (elites.json + reserves.json)
    When Updated: 
      - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:916)
      - Calculated from actual files
    Why: Tracks average fitness in population

--------------------------------------------------------------------------------
BUDGET FIELDS (within generation.budget object)
--------------------------------------------------------------------------------

1. llm_calls
   Type: integer
   Calculation: Number of LLM calls made in this generation (genomes with generated_output)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2034)
     - Calculated via calculate_budget_metrics() (population_io.py:1536-1604)
   Why: Tracks LLM usage cost

2. api_calls
   Type: integer
   Calculation: Number of Perspective API calls made in this generation (genomes with moderation_result)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2035)
     - Calculated via calculate_budget_metrics()
   Why: Tracks API usage cost

3. total_response_time
   Type: float
   Calculation: Sum of response_duration for all LLM calls in this generation (seconds)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2036)
     - Calculated via calculate_budget_metrics()
   Why: Tracks LLM processing time

4. total_evaluation_time
   Type: float
   Calculation: Sum of evaluation_duration for all API calls in this generation (seconds)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2037)
     - Calculated via calculate_budget_metrics()
   Why: Tracks API processing time

--------------------------------------------------------------------------------
SPECIATION_SUMMARY FIELDS (root level)
--------------------------------------------------------------------------------

1. current_species_count
   Type: integer
   Calculation: Number of species in current state (from speciation_state.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:899)
     - From get_speciation_statistics() (run_speciation.py:846)
   Why: Quick access to current species count

2. current_reserves_size
   Type: integer
   Calculation: Current size of reserves (from reserves.json)
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:900)
     - From get_speciation_statistics()
   Why: Quick access to current reserves size

3. total_speciation_events
   Type: integer
   Calculation: Sum of speciation_events across all generations
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:901)
     - Aggregated from generations
   Why: Cumulative speciation activity

4. total_merge_events
   Type: integer
   Calculation: Sum of merge_events across all generations
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:902)
     - Aggregated from generations
   Why: Cumulative merge activity

5. total_extinction_events
   Type: integer
   Calculation: Sum of extinction_events across all generations
   When Updated: 
     - Updated in update_evolution_tracker_with_speciation() (run_speciation.py:903)
     - Aggregated from generations
   Why: Cumulative extinction activity

--------------------------------------------------------------------------------
CUMULATIVE_BUDGET FIELDS (root level)
--------------------------------------------------------------------------------

1. total_llm_calls
   Type: integer
   Calculation: Sum of llm_calls across all generations
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2049)
     - Accumulated each generation
   Why: Total LLM usage

2. total_api_calls
   Type: integer
   Calculation: Sum of api_calls across all generations
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2050)
     - Accumulated each generation
   Why: Total API usage

3. total_response_time
   Type: float
   Calculation: Sum of total_response_time across all generations (seconds)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2051-2053)
     - Accumulated each generation
   Why: Total LLM processing time

4. total_evaluation_time
   Type: float
   Calculation: Sum of total_evaluation_time across all generations (seconds)
   When Updated: 
     - Updated in update_evolution_tracker_with_statistics() (population_io.py:2054-2056)
     - Accumulated each generation
   Why: Total API processing time

================================================================================
SECTION 2: speciation_state.json
================================================================================

speciation_state.json stores the complete state of the speciation module,
including all species, cluster 0 metadata, global best, and metrics history.
This file is used to restore speciation state across generations.

--------------------------------------------------------------------------------
ROOT LEVEL FIELDS
--------------------------------------------------------------------------------

1. species
   Type: object (dictionary keyed by species ID as string)
   Description: All active species (see SPECIES OBJECT FIELDS below)
   When Updated: 
     - Updated in save_state() (run_speciation.py:484)
     - Called after distribute_genomes() to ensure accurate sizes
   Why: Persists species state for restoration

2. cluster0
   Type: object
   Description: Cluster 0 (reserves) metadata (see CLUSTER0 FIELDS below)
   When Updated: 
     - Updated in save_state() (run_speciation.py:528)
     - From Cluster0.to_dict() (reserves.py:317)
   Why: Tracks reserves state (full genome data in reserves.json)

3. global_best_id
   Type: integer or null
   Calculation: ID of the globally best genome across all generations
   When Updated: 
     - Updated in save_state() (run_speciation.py:529)
     - From state["global_best"].id if exists
   Why: Tracks best genome for analysis

4. metrics
   Type: object
   Description: Speciation metrics history (see METRICS FIELDS below)
   When Updated: 
     - Updated in save_state() (run_speciation.py:530)
     - From SpeciationMetricsTracker.to_dict() (metrics.py:102)
   Why: Historical speciation metrics

--------------------------------------------------------------------------------
SPECIES OBJECT FIELDS (within species object)
--------------------------------------------------------------------------------

1. id
   Type: integer
   Calculation: Unique species identifier (1, 2, 3, ...)
   When Updated: 
     - Set when species is created (SpeciesIdGenerator.next_id())
     - Never changes
   Why: Unique species identification

2. leader_id
   Type: integer
   Calculation: ID of the leader individual (highest fitness in species)
   When Updated: 
     - Updated immediately when a genome with higher fitness is assigned to species
     - From Species.to_dict() (species.py:319)
   Why: Identifies species center

3. leader_prompt
   Type: string
   Calculation: Prompt text of the leader individual
   When Updated: 
     - Updated when leader changes
     - From Species.to_dict() (species.py:320)
   Why: Human-readable species representation

4. leader_embedding
   Type: array of floats (384 dimensions) or null
   Calculation: L2-normalized semantic embedding of leader prompt
   When Updated: 
     - Updated when leader changes
     - From Species.to_dict() (species.py:321)
   Why: Used for distance calculations in clustering

5. leader_fitness
   Type: float
   Calculation: Fitness score of the leader (north_star_score/toxicity)
   When Updated: 
     - Updated when leader changes
     - From Species.to_dict() (species.py:322)
   Why: Tracks species best fitness

6. member_ids
   Type: array of integers
   Calculation: IDs of all members in this species (from current generation only)
   When Updated: 
     - Updated in Species.to_dict() (species.py:323)
     - Reflects members in Species.members (current generation)
   Why: Tracks species membership (note: full membership across generations in elites.json)

7. radius
   Type: float
   Calculation: Constant radius for species membership (theta_sim, default: 0.2)
   When Updated: 
     - Set when species is created
     - Constant for all species
   Why: Defines species boundary

8. stagnation
   Type: integer
   Calculation: Number of generations without max_fitness improvement
   When Updated: 
     - Updated in process_extinctions() (extinction.py)
     - Incremented each generation if no improvement
   Why: Tracks stagnation for extinction detection

9. max_fitness
   Type: float
   Calculation: Current maximum fitness in this species
   When Updated: 
     - Updated when leader changes or fitness recorded
     - From Species.max_fitness property
   Why: Tracks species best fitness

10. species_state
    Type: string
    Values: "active", "stagnant", "frozen"
    Calculation: 
      - "active": Normal operation
      - "stagnant": No improvement for some generations
      - "frozen": Extinct (stagnation >= max_stagnation)
    When Updated: 
      - Updated in process_extinctions() (extinction.py)
      - Based on stagnation count
    Why: Tracks species lifecycle state

11. created_at
    Type: integer
    Calculation: Generation number when species was created
    When Updated: 
      - Set when species is created
      - Never changes
    Why: Tracks species age

12. last_improvement
    Type: integer
    Calculation: Generation number when fitness last improved
    When Updated: 
      - Updated in Species.record_fitness() (species.py:291)
      - Set to current generation when improvement detected
    Why: Tracks improvement history

13. fitness_history
    Type: array of floats
    Calculation: List of best fitness values per generation (last 20)
    When Updated: 
      - Updated in Species.record_fitness() (species.py:291)
      - Appended each generation
    Why: Tracks fitness trends

14. labels
    Type: array of strings
    Calculation: Current c-TF-IDF labels (top 10 representative words)
    When Updated: 
      - Updated in update_species_labels() (labeling.py:260)
      - Generated via extract_species_labels() (labeling.py:184)
    Why: Semantic characterization of species

15. label_history
    Type: array of objects
    Description: Historical labels with fitness metrics (last 20 generations)
    Each entry contains:
      - generation: Generation number
      - labels: Array of label strings
      - best_fitness: Best fitness at this generation
      - avg_fitness: Average fitness at this generation
      - size: Species size at this generation
    When Updated: 
      - Updated in update_species_labels() (labeling.py:260)
      - Appended each generation when species is updated
    Why: Tracks semantic evolution of species

16. cluster_origin
    Type: string or null
    Values: "natural", "merge", "split", null
    Calculation: 
      - "natural": Created naturally during clustering
      - "merge": Created by merging two species
      - "split": Created by splitting a species (future)
      - null: Unknown/legacy
    When Updated: 
      - Set when species is created
      - From Species.cluster_origin
    Why: Tracks species origin

17. parent_ids
    Type: array of integers or null
    Calculation: 
      - null or []: Natural creation (no parent)
      - [id1, id2]: Merged from two parent species
      - [id1]: Split from single parent (future)
    When Updated: 
      - Set when species is created
      - From Species.parent_ids
    Why: Tracks species lineage

18. size
    Type: integer
    Calculation: Total number of genomes in this species across ALL generations (from elites.json)
    When Updated: 
      - Updated in save_state() (run_speciation.py:507-523)
      - Calculated by counting genomes in elites.json with matching species_id
      - NOT from Species.members (which only has current generation)
    Why: Accurate species size across all generations

--------------------------------------------------------------------------------
CLUSTER0 FIELDS (within cluster0 object)
--------------------------------------------------------------------------------

1. cluster_id
   Type: integer
   Calculation: Always 0 (reserved for cluster 0)
   When Updated: Constant
   Why: Identifies cluster 0

2. size
   Type: integer
   Calculation: Number of genomes in reserves.json (species_id = 0)
   When Updated: 
     - Updated in Cluster0.to_dict() (reserves.py:317)
     - From Cluster0.size property
   Why: Tracks reserves size

3. max_capacity
   Type: integer
   Calculation: Maximum capacity for cluster 0 (default: 1000)
   When Updated: 
     - Set during Cluster0 initialization
     - Constant
   Why: Capacity limit

4. speciation_events
   Type: array of objects
   Description: History of speciation events from cluster 0
   Each entry contains:
     - generation: Generation when speciation occurred
     - species_id: ID of new species created
     - size: Size of new species
     - leader_fitness: Fitness of new species leader
     - origin: "cluster_0_speciation"
   When Updated: 
     - Updated in Cluster0.check_speciation() (reserves.py:199)
     - When new species are created from reserves
   Why: Tracks speciation from reserves

--------------------------------------------------------------------------------
METRICS FIELDS (within metrics object)
--------------------------------------------------------------------------------

1. history
   Type: array of objects
   Description: Per-generation metrics history
   Each entry contains:
     - generation: Generation number
     - species_count: Number of species
     - total_population: Total population (elites + reserves)
     - reserves_size: Size of reserves
     - best_fitness: Best fitness in population
     - avg_fitness: Average fitness in population
     - speciation_events: Number of speciation events
     - merge_events: Number of merge events
     - extinction_events: Number of extinction events
   When Updated: 
     - Updated in SpeciationMetricsTracker.record_generation() (metrics.py:54)
     - Called after each generation processing
   Why: Historical speciation metrics

2. summary
   Type: object
   Description: Cumulative summary statistics
   Contains:
     - total_generations: Number of generations processed
     - final_species_count: Current species count
     - best_fitness_ever: Maximum fitness across all generations
     - total_speciation_events: Cumulative speciation events
     - total_merge_events: Cumulative merge events
     - total_extinction_events: Cumulative extinction events
   When Updated: 
     - Updated in SpeciationMetricsTracker.get_summary() (metrics.py:90)
     - Calculated from history
   Why: Quick access to summary statistics

================================================================================
KEY DIFFERENCES AND NOTES
================================================================================

1. EvolutionTracker.json tracks EVOLUTION progress (variants, operators, budget)
   speciation_state.json tracks SPECIATION state (species, clustering, diversity)

2. EvolutionTracker.json is updated AFTER each generation completes
   speciation_state.json is updated DURING speciation processing

3. EvolutionTracker.json uses actual file counts (elites.json + reserves.json)
   speciation_state.json species.size uses actual file counts (elites.json)

4. EvolutionTracker.json has per-generation speciation summary
   speciation_state.json has detailed species-level data

5. Both files are updated independently and serve different purposes:
   - EvolutionTracker.json: Overall evolution analysis
   - speciation_state.json: Speciation state restoration

================================================================================
END OF DOCUMENTATION
================================================================================
